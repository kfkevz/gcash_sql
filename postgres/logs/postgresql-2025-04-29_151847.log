2025-04-29 15:18:47.539 UTC [48] LOG:  starting PostgreSQL 16.8 (Debian 16.8-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit
2025-04-29 15:18:47.542 UTC [48] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2025-04-29 15:18:47.548 UTC [52] LOG:  database system was shut down at 2025-04-29 15:18:47 UTC
2025-04-29 15:18:47.552 UTC [48] LOG:  database system is ready to accept connections
2025-04-29 15:18:47.709 UTC [58] LOG:  statement: SELECT 1 FROM pg_database WHERE datname = 'gcash_db' ;
2025-04-29 15:18:47.743 UTC [60] LOG:  statement: CREATE DATABASE "gcash_db" ;
2025-04-29 15:18:47.783 UTC [48] LOG:  received fast shutdown request
2025-04-29 15:18:47.786 UTC [48] LOG:  aborting any active transactions
2025-04-29 15:18:47.788 UTC [48] LOG:  background worker "logical replication launcher" (PID 55) exited with exit code 1
2025-04-29 15:18:47.788 UTC [50] LOG:  shutting down
2025-04-29 15:18:47.791 UTC [50] LOG:  checkpoint starting: shutdown immediate
2025-04-29 15:18:47.861 UTC [50] LOG:  checkpoint complete: wrote 922 buffers (5.6%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.018 s, sync=0.041 s, total=0.073 s; sync files=301, longest=0.003 s, average=0.001 s; distance=4255 kB, estimate=4255 kB; lsn=0/1912100, redo lsn=0/1912100
2025-04-29 15:18:47.865 UTC [48] LOG:  database system is shut down
2025-04-29 15:18:47.924 UTC [1] LOG:  starting PostgreSQL 16.8 (Debian 16.8-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit
2025-04-29 15:18:47.926 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432
2025-04-29 15:18:47.926 UTC [1] LOG:  listening on IPv6 address "::", port 5432
2025-04-29 15:18:47.934 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2025-04-29 15:18:47.942 UTC [66] LOG:  database system was shut down at 2025-04-29 15:18:47 UTC
2025-04-29 15:18:47.948 UTC [1] LOG:  database system is ready to accept connections
2025-04-29 15:18:52.588 UTC [79] LOG:  statement: 
	      DO $$ 
	      BEGIN
	        IF EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type') THEN
	          DROP TYPE transaction_type CASCADE;
	        END IF;
	        CREATE TYPE transaction_type AS ENUM ('Cash In', 'Cash Out', 'Load');
	      END $$;
	    
2025-04-29 15:18:52.593 UTC [79] LOG:  statement: 
	      CREATE TABLE IF NOT EXISTS Transactions (
	        id SERIAL PRIMARY KEY,
	        date TEXT NOT NULL,
	        time TEXT NOT NULL,
	        type transaction_type NOT NULL,
	        amount TEXT NOT NULL,
	        name TEXT NOT NULL,
	        ref TEXT NOT NULL,
	        fee TEXT NOT NULL,
	        remarks TEXT NOT NULL,
	        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
	      );
	    
2025-04-29 15:18:52.607 UTC [79] LOG:  statement: 
	      DO $$ 
	      BEGIN
	        IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
	                       WHERE table_name = 'transactions' AND column_name = 'created_at') THEN
	          ALTER TABLE Transactions ADD COLUMN created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;
	        END IF;
	        IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
	                       WHERE table_name = 'transactions' AND column_name = 'updated_at') THEN
	          ALTER TABLE Transactions ADD COLUMN updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;
	        END IF;
	      END $$;
	    
2025-04-29 15:18:52.616 UTC [79] LOG:  statement: 
	      CREATE TABLE IF NOT EXISTS CurrentBalance (
	        id SERIAL PRIMARY KEY,
	        balance DECIMAL NOT NULL DEFAULT 0.00
	      );
	    
2025-04-29 15:18:52.630 UTC [79] LOG:  statement: SELECT * FROM CurrentBalance
2025-04-29 15:18:52.631 UTC [79] LOG:  statement: INSERT INTO CurrentBalance (balance) VALUES (0.00)
2025-04-29 15:18:59.376 UTC [79] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 15:18:59.391 UTC [79] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:18:59.399 UTC [80] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 15:18:59.399 UTC [80] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 15:18:59.408 UTC [80] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:19:16.571 UTC [97] LOG:  execute <unnamed>: INSERT INTO Transactions (date, time, type, amount, name, ref, fee, remarks, created_at, updated_at)
	       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
	       RETURNING id
2025-04-29 15:19:16.571 UTC [97] DETAIL:  parameters: $1 = '2025-04-29', $2 = '11:19', $3 = 'Cash In', $4 = '2000', $5 = 'KFA', $6 = '23412', $7 = '40', $8 = 'SENT'
2025-04-29 15:19:16.582 UTC [97] LOG:  execute <unnamed>: UPDATE CurrentBalance SET balance = balance + $1 WHERE id = 1
2025-04-29 15:19:16.582 UTC [97] DETAIL:  parameters: $1 = '-2000'
2025-04-29 15:19:17.215 UTC [97] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 15:19:17.215 UTC [97] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 15:19:17.218 UTC [97] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 15:19:17.226 UTC [97] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:19:31.096 UTC [107] LOG:  execute <unnamed>: INSERT INTO Transactions (date, time, type, amount, name, ref, fee, remarks, created_at, updated_at)
	       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
	       RETURNING id
2025-04-29 15:19:31.096 UTC [107] DETAIL:  parameters: $1 = '2025-04-29', $2 = '11:19', $3 = 'Cash Out', $4 = '500', $5 = 'KEV', $6 = '24123', $7 = '10', $8 = 'CLAIMED'
2025-04-29 15:19:31.105 UTC [107] LOG:  execute <unnamed>: UPDATE CurrentBalance SET balance = balance + $1 WHERE id = 1
2025-04-29 15:19:31.105 UTC [107] DETAIL:  parameters: $1 = '500'
2025-04-29 15:19:31.885 UTC [107] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 15:19:31.885 UTC [107] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 15:19:31.889 UTC [107] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 15:19:31.895 UTC [107] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:19:44.183 UTC [125] LOG:  execute <unnamed>: INSERT INTO Transactions (date, time, type, amount, name, ref, fee, remarks, created_at, updated_at)
	       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
	       RETURNING id
2025-04-29 15:19:44.183 UTC [125] DETAIL:  parameters: $1 = '2025-04-29', $2 = '11:19', $3 = 'Load', $4 = '20', $5 = 'AN20', $6 = '12312', $7 = '5', $8 = 'LOAD'
2025-04-29 15:19:44.192 UTC [125] LOG:  execute <unnamed>: UPDATE CurrentBalance SET balance = balance + $1 WHERE id = 1
2025-04-29 15:19:44.192 UTC [125] DETAIL:  parameters: $1 = '-20'
2025-04-29 15:19:44.493 UTC [125] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 15:19:44.493 UTC [125] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 15:19:44.496 UTC [125] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 15:19:44.503 UTC [125] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:19:49.228 UTC [126] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:19:49.232 UTC [126] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2025-04-29 15:19:49.233 UTC [126] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:19:49.234 UTC [126] LOG:  statement: SET DATESTYLE = ISO
2025-04-29 15:19:49.234 UTC [126] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2025-04-29 15:19:49.234 UTC [126] LOG:  statement: SET extra_float_digits TO 3
2025-04-29 15:19:49.235 UTC [126] LOG:  statement: SET synchronize_seqscans TO off
2025-04-29 15:19:49.235 UTC [126] LOG:  statement: SET statement_timeout = 0
2025-04-29 15:19:49.235 UTC [126] LOG:  statement: SET lock_timeout = 0
2025-04-29 15:19:49.235 UTC [126] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2025-04-29 15:19:49.235 UTC [126] LOG:  statement: SET row_security = off
2025-04-29 15:19:49.236 UTC [126] LOG:  statement: SELECT set_config(name, 'view, foreign-table', false) FROM pg_settings WHERE name = 'restrict_nonsystem_relation_kind'
2025-04-29 15:19:49.242 UTC [126] LOG:  statement: BEGIN
2025-04-29 15:19:49.243 UTC [126] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2025-04-29 15:19:49.243 UTC [126] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2025-04-29 15:19:49.246 UTC [126] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2025-04-29 15:19:49.251 UTC [126] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2025-04-29 15:19:49.259 UTC [126] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2025-04-29 15:19:49.260 UTC [126] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2025-04-29 15:19:49.283 UTC [126] LOG:  statement: LOCK TABLE public.transactions, public.currentbalance IN ACCESS SHARE MODE
2025-04-29 15:19:49.283 UTC [126] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:19:49.304 UTC [126] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2025-04-29 15:19:49.310 UTC [126] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2025-04-29 15:19:49.312 UTC [126] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:19:49.313 UTC [126] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2025-04-29 15:19:49.316 UTC [126] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2025-04-29 15:19:49.321 UTC [126] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2025-04-29 15:19:49.322 UTC [126] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2025-04-29 15:19:49.326 UTC [126] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2025-04-29 15:19:49.330 UTC [126] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2025-04-29 15:19:49.333 UTC [126] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2025-04-29 15:19:49.337 UTC [126] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2025-04-29 15:19:49.340 UTC [126] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2025-04-29 15:19:49.345 UTC [126] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2025-04-29 15:19:49.346 UTC [126] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2025-04-29 15:19:49.347 UTC [126] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2025-04-29 15:19:49.351 UTC [126] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2025-04-29 15:19:49.355 UTC [126] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2025-04-29 15:19:49.360 UTC [126] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2025-04-29 15:19:49.360 UTC [126] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2025-04-29 15:19:49.362 UTC [126] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2025-04-29 15:19:49.363 UTC [126] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2025-04-29 15:19:49.365 UTC [126] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2025-04-29 15:19:49.367 UTC [126] LOG:  statement: SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)
	ORDER BY a.adrelid, a.adnum
2025-04-29 15:19:49.368 UTC [126] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2025-04-29 15:19:49.370 UTC [126] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2025-04-29 15:19:49.373 UTC [126] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxrelid, stxstattarget FROM pg_catalog.pg_statistic_ext
2025-04-29 15:19:49.374 UTC [126] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2025-04-29 15:19:49.374 UTC [126] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2025-04-29 15:19:49.377 UTC [126] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2025-04-29 15:19:49.379 UTC [126] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2025-04-29 15:19:49.381 UTC [126] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2025-04-29 15:19:49.382 UTC [126] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2025-04-29 15:19:49.384 UTC [126] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2025-04-29 15:19:49.385 UTC [126] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr,
	 s.subpasswordrequired,
	 s.subrunasowner,
	 s.suborigin
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2025-04-29 15:19:49.387 UTC [126] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2025-04-29 15:19:49.389 UTC [126] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2025-04-29 15:19:49.390 UTC [126] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2025-04-29 15:19:49.397 UTC [126] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2025-04-29 15:19:49.400 UTC [126] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2025-04-29 15:19:49.401 UTC [126] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2025-04-29 15:19:49.410 UTC [126] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2025-04-29 15:19:49.413 UTC [126] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2025-04-29 15:19:49.413 UTC [126] LOG:  statement: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:19:49.413 UTC [126] LOG:  statement: EXECUTE dumpEnumType('16386')
2025-04-29 15:19:49.413 UTC [126] DETAIL:  prepare: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:19:49.415 UTC [126] LOG:  statement: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:19:49.415 UTC [126] LOG:  statement: EXECUTE getColumnACLs('6100')
2025-04-29 15:19:49.415 UTC [126] DETAIL:  prepare: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:19:49.416 UTC [126] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16404'::oid
2025-04-29 15:19:49.416 UTC [126] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16393'::oid
2025-04-29 15:19:49.416 UTC [126] LOG:  statement: SELECT last_value, is_called FROM public.currentbalance_id_seq
2025-04-29 15:19:49.417 UTC [126] LOG:  statement: SELECT last_value, is_called FROM public.transactions_id_seq
2025-04-29 15:19:49.417 UTC [126] LOG:  statement: COPY public.currentbalance (id, balance) TO stdout;
2025-04-29 15:19:49.417 UTC [126] LOG:  statement: COPY public.transactions (id, date, "time", type, amount, name, ref, fee, remarks, created_at, updated_at) TO stdout;
2025-04-29 15:22:39.035 UTC [271] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:22:39.036 UTC [271] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2025-04-29 15:22:39.036 UTC [271] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:22:39.037 UTC [271] LOG:  statement: SET DATESTYLE = ISO
2025-04-29 15:22:39.037 UTC [271] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2025-04-29 15:22:39.038 UTC [271] LOG:  statement: SET extra_float_digits TO 3
2025-04-29 15:22:39.038 UTC [271] LOG:  statement: SET synchronize_seqscans TO off
2025-04-29 15:22:39.038 UTC [271] LOG:  statement: SET statement_timeout = 0
2025-04-29 15:22:39.039 UTC [271] LOG:  statement: SET lock_timeout = 0
2025-04-29 15:22:39.039 UTC [271] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2025-04-29 15:22:39.039 UTC [271] LOG:  statement: SET row_security = off
2025-04-29 15:22:39.040 UTC [271] LOG:  statement: SELECT set_config(name, 'view, foreign-table', false) FROM pg_settings WHERE name = 'restrict_nonsystem_relation_kind'
2025-04-29 15:22:39.042 UTC [271] LOG:  statement: BEGIN
2025-04-29 15:22:39.042 UTC [271] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2025-04-29 15:22:39.043 UTC [271] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2025-04-29 15:22:39.044 UTC [271] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2025-04-29 15:22:39.045 UTC [271] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2025-04-29 15:22:39.046 UTC [271] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2025-04-29 15:22:39.047 UTC [271] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2025-04-29 15:22:39.052 UTC [271] LOG:  statement: LOCK TABLE public.transactions, public.currentbalance IN ACCESS SHARE MODE
2025-04-29 15:22:39.052 UTC [271] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:22:39.057 UTC [271] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2025-04-29 15:22:39.060 UTC [271] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2025-04-29 15:22:39.060 UTC [271] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:22:39.061 UTC [271] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2025-04-29 15:22:39.062 UTC [271] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2025-04-29 15:22:39.062 UTC [271] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2025-04-29 15:22:39.063 UTC [271] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2025-04-29 15:22:39.063 UTC [271] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2025-04-29 15:22:39.064 UTC [271] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2025-04-29 15:22:39.064 UTC [271] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2025-04-29 15:22:39.065 UTC [271] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2025-04-29 15:22:39.065 UTC [271] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2025-04-29 15:22:39.066 UTC [271] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2025-04-29 15:22:39.066 UTC [271] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2025-04-29 15:22:39.067 UTC [271] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2025-04-29 15:22:39.068 UTC [271] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2025-04-29 15:22:39.068 UTC [271] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2025-04-29 15:22:39.069 UTC [271] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2025-04-29 15:22:39.069 UTC [271] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2025-04-29 15:22:39.070 UTC [271] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2025-04-29 15:22:39.070 UTC [271] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2025-04-29 15:22:39.071 UTC [271] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2025-04-29 15:22:39.072 UTC [271] LOG:  statement: SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)
	ORDER BY a.adrelid, a.adnum
2025-04-29 15:22:39.073 UTC [271] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2025-04-29 15:22:39.073 UTC [271] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2025-04-29 15:22:39.075 UTC [271] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxrelid, stxstattarget FROM pg_catalog.pg_statistic_ext
2025-04-29 15:22:39.076 UTC [271] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2025-04-29 15:22:39.076 UTC [271] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2025-04-29 15:22:39.077 UTC [271] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2025-04-29 15:22:39.078 UTC [271] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2025-04-29 15:22:39.079 UTC [271] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2025-04-29 15:22:39.079 UTC [271] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2025-04-29 15:22:39.079 UTC [271] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2025-04-29 15:22:39.080 UTC [271] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr,
	 s.subpasswordrequired,
	 s.subrunasowner,
	 s.suborigin
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2025-04-29 15:22:39.081 UTC [271] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2025-04-29 15:22:39.083 UTC [271] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2025-04-29 15:22:39.083 UTC [271] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2025-04-29 15:22:39.085 UTC [271] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2025-04-29 15:22:39.086 UTC [271] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2025-04-29 15:22:39.087 UTC [271] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2025-04-29 15:22:39.092 UTC [271] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2025-04-29 15:22:39.094 UTC [271] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2025-04-29 15:22:39.095 UTC [271] LOG:  statement: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:22:39.095 UTC [271] LOG:  statement: EXECUTE dumpEnumType('16386')
2025-04-29 15:22:39.095 UTC [271] DETAIL:  prepare: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:22:39.095 UTC [271] LOG:  statement: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:22:39.096 UTC [271] LOG:  statement: EXECUTE getColumnACLs('6100')
2025-04-29 15:22:39.096 UTC [271] DETAIL:  prepare: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:22:39.096 UTC [271] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16404'::oid
2025-04-29 15:22:39.097 UTC [271] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16393'::oid
2025-04-29 15:22:39.097 UTC [271] LOG:  statement: SELECT last_value, is_called FROM public.currentbalance_id_seq
2025-04-29 15:22:39.097 UTC [271] LOG:  statement: SELECT last_value, is_called FROM public.transactions_id_seq
2025-04-29 15:22:39.098 UTC [271] LOG:  statement: COPY public.currentbalance (id, balance) TO stdout;
2025-04-29 15:22:39.098 UTC [271] LOG:  statement: COPY public.transactions (id, date, "time", type, amount, name, ref, fee, remarks, created_at, updated_at) TO stdout;
2025-04-29 15:23:09.796 UTC [297] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:23:09.797 UTC [297] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2025-04-29 15:23:09.797 UTC [297] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:23:09.797 UTC [297] LOG:  statement: SET DATESTYLE = ISO
2025-04-29 15:23:09.798 UTC [297] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2025-04-29 15:23:09.798 UTC [297] LOG:  statement: SET extra_float_digits TO 3
2025-04-29 15:23:09.798 UTC [297] LOG:  statement: SET synchronize_seqscans TO off
2025-04-29 15:23:09.798 UTC [297] LOG:  statement: SET statement_timeout = 0
2025-04-29 15:23:09.799 UTC [297] LOG:  statement: SET lock_timeout = 0
2025-04-29 15:23:09.799 UTC [297] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2025-04-29 15:23:09.799 UTC [297] LOG:  statement: SET row_security = off
2025-04-29 15:23:09.799 UTC [297] LOG:  statement: SELECT set_config(name, 'view, foreign-table', false) FROM pg_settings WHERE name = 'restrict_nonsystem_relation_kind'
2025-04-29 15:23:09.801 UTC [297] LOG:  statement: BEGIN
2025-04-29 15:23:09.801 UTC [297] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2025-04-29 15:23:09.801 UTC [297] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2025-04-29 15:23:09.802 UTC [297] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2025-04-29 15:23:09.803 UTC [297] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2025-04-29 15:23:09.804 UTC [297] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2025-04-29 15:23:09.804 UTC [297] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2025-04-29 15:23:09.807 UTC [297] LOG:  statement: LOCK TABLE public.transactions, public.currentbalance IN ACCESS SHARE MODE
2025-04-29 15:23:09.807 UTC [297] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:23:09.810 UTC [297] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2025-04-29 15:23:09.812 UTC [297] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2025-04-29 15:23:09.813 UTC [297] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:23:09.814 UTC [297] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2025-04-29 15:23:09.814 UTC [297] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2025-04-29 15:23:09.815 UTC [297] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2025-04-29 15:23:09.815 UTC [297] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2025-04-29 15:23:09.816 UTC [297] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2025-04-29 15:23:09.816 UTC [297] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2025-04-29 15:23:09.816 UTC [297] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2025-04-29 15:23:09.817 UTC [297] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2025-04-29 15:23:09.817 UTC [297] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2025-04-29 15:23:09.818 UTC [297] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2025-04-29 15:23:09.818 UTC [297] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2025-04-29 15:23:09.819 UTC [297] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2025-04-29 15:23:09.820 UTC [297] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2025-04-29 15:23:09.820 UTC [297] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2025-04-29 15:23:09.821 UTC [297] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2025-04-29 15:23:09.821 UTC [297] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2025-04-29 15:23:09.822 UTC [297] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2025-04-29 15:23:09.822 UTC [297] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2025-04-29 15:23:09.823 UTC [297] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2025-04-29 15:23:09.824 UTC [297] LOG:  statement: SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)
	ORDER BY a.adrelid, a.adnum
2025-04-29 15:23:09.824 UTC [297] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2025-04-29 15:23:09.825 UTC [297] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2025-04-29 15:23:09.827 UTC [297] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxrelid, stxstattarget FROM pg_catalog.pg_statistic_ext
2025-04-29 15:23:09.827 UTC [297] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2025-04-29 15:23:09.828 UTC [297] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2025-04-29 15:23:09.829 UTC [297] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2025-04-29 15:23:09.829 UTC [297] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2025-04-29 15:23:09.830 UTC [297] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2025-04-29 15:23:09.830 UTC [297] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2025-04-29 15:23:09.831 UTC [297] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2025-04-29 15:23:09.831 UTC [297] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr,
	 s.subpasswordrequired,
	 s.subrunasowner,
	 s.suborigin
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2025-04-29 15:23:09.832 UTC [297] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2025-04-29 15:23:09.833 UTC [297] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2025-04-29 15:23:09.833 UTC [297] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2025-04-29 15:23:09.835 UTC [297] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2025-04-29 15:23:09.836 UTC [297] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2025-04-29 15:23:09.836 UTC [297] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2025-04-29 15:23:09.842 UTC [297] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2025-04-29 15:23:09.845 UTC [297] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2025-04-29 15:23:09.845 UTC [297] LOG:  statement: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:23:09.845 UTC [297] LOG:  statement: EXECUTE dumpEnumType('16386')
2025-04-29 15:23:09.845 UTC [297] DETAIL:  prepare: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:23:09.846 UTC [297] LOG:  statement: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:23:09.846 UTC [297] LOG:  statement: EXECUTE getColumnACLs('6100')
2025-04-29 15:23:09.846 UTC [297] DETAIL:  prepare: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:23:09.847 UTC [297] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16404'::oid
2025-04-29 15:23:09.847 UTC [297] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16393'::oid
2025-04-29 15:23:09.848 UTC [297] LOG:  statement: SELECT last_value, is_called FROM public.currentbalance_id_seq
2025-04-29 15:23:09.848 UTC [297] LOG:  statement: SELECT last_value, is_called FROM public.transactions_id_seq
2025-04-29 15:23:09.848 UTC [297] LOG:  statement: COPY public.currentbalance (id, balance) TO stdout;
2025-04-29 15:23:09.848 UTC [297] LOG:  statement: COPY public.transactions (id, date, "time", type, amount, name, ref, fee, remarks, created_at, updated_at) TO stdout;
2025-04-29 15:23:39.122 UTC [324] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 15:23:39.122 UTC [324] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 15:23:39.132 UTC [324] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:23:42.941 UTC [324] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 15:23:42.950 UTC [324] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 15:23:42.950 UTC [324] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 15:23:42.970 UTC [324] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:23:48.023 UTC [64] LOG:  checkpoint starting: time
2025-04-29 15:23:54.097 UTC [341] LOG:  execute <unnamed>: INSERT INTO Transactions (date, time, type, amount, name, ref, fee, remarks, created_at, updated_at)
	       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
	       RETURNING id
2025-04-29 15:23:54.097 UTC [341] DETAIL:  parameters: $1 = '2025-04-29', $2 = '11:23', $3 = 'Cash In', $4 = '100', $5 = 'KFA', $6 = '12412', $7 = '10', $8 = 'SENT'
2025-04-29 15:23:54.107 UTC [341] LOG:  execute <unnamed>: UPDATE CurrentBalance SET balance = balance + $1 WHERE id = 1
2025-04-29 15:23:54.107 UTC [341] DETAIL:  parameters: $1 = '-100'
2025-04-29 15:23:55.896 UTC [341] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 15:23:55.896 UTC [341] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 15:23:55.900 UTC [341] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 15:23:55.905 UTC [341] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:23:59.458 UTC [64] LOG:  checkpoint complete: wrote 116 buffers (0.7%); 0 WAL file(s) added, 0 removed, 0 recycled; write=11.361 s, sync=0.049 s, total=11.435 s; sync files=62, longest=0.008 s, average=0.001 s; distance=479 kB, estimate=479 kB; lsn=0/198A3B0, redo lsn=0/1989EE8
2025-04-29 15:23:59.661 UTC [343] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:23:59.661 UTC [343] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2025-04-29 15:23:59.661 UTC [343] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:23:59.662 UTC [343] LOG:  statement: SET DATESTYLE = ISO
2025-04-29 15:23:59.662 UTC [343] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2025-04-29 15:23:59.662 UTC [343] LOG:  statement: SET extra_float_digits TO 3
2025-04-29 15:23:59.662 UTC [343] LOG:  statement: SET synchronize_seqscans TO off
2025-04-29 15:23:59.662 UTC [343] LOG:  statement: SET statement_timeout = 0
2025-04-29 15:23:59.662 UTC [343] LOG:  statement: SET lock_timeout = 0
2025-04-29 15:23:59.663 UTC [343] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2025-04-29 15:23:59.663 UTC [343] LOG:  statement: SET row_security = off
2025-04-29 15:23:59.663 UTC [343] LOG:  statement: SELECT set_config(name, 'view, foreign-table', false) FROM pg_settings WHERE name = 'restrict_nonsystem_relation_kind'
2025-04-29 15:23:59.665 UTC [343] LOG:  statement: BEGIN
2025-04-29 15:23:59.665 UTC [343] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2025-04-29 15:23:59.665 UTC [343] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2025-04-29 15:23:59.666 UTC [343] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2025-04-29 15:23:59.666 UTC [343] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2025-04-29 15:23:59.667 UTC [343] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2025-04-29 15:23:59.668 UTC [343] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2025-04-29 15:23:59.670 UTC [343] LOG:  statement: LOCK TABLE public.transactions, public.currentbalance IN ACCESS SHARE MODE
2025-04-29 15:23:59.671 UTC [343] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:23:59.674 UTC [343] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2025-04-29 15:23:59.676 UTC [343] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2025-04-29 15:23:59.677 UTC [343] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:23:59.678 UTC [343] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2025-04-29 15:23:59.679 UTC [343] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2025-04-29 15:23:59.679 UTC [343] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2025-04-29 15:23:59.680 UTC [343] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2025-04-29 15:23:59.680 UTC [343] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2025-04-29 15:23:59.681 UTC [343] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2025-04-29 15:23:59.681 UTC [343] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2025-04-29 15:23:59.682 UTC [343] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2025-04-29 15:23:59.682 UTC [343] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2025-04-29 15:23:59.682 UTC [343] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2025-04-29 15:23:59.683 UTC [343] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2025-04-29 15:23:59.683 UTC [343] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2025-04-29 15:23:59.684 UTC [343] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2025-04-29 15:23:59.684 UTC [343] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2025-04-29 15:23:59.685 UTC [343] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2025-04-29 15:23:59.685 UTC [343] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2025-04-29 15:23:59.686 UTC [343] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2025-04-29 15:23:59.686 UTC [343] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2025-04-29 15:23:59.687 UTC [343] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2025-04-29 15:23:59.688 UTC [343] LOG:  statement: SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)
	ORDER BY a.adrelid, a.adnum
2025-04-29 15:23:59.688 UTC [343] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2025-04-29 15:23:59.689 UTC [343] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2025-04-29 15:23:59.691 UTC [343] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxrelid, stxstattarget FROM pg_catalog.pg_statistic_ext
2025-04-29 15:23:59.691 UTC [343] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2025-04-29 15:23:59.691 UTC [343] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2025-04-29 15:23:59.692 UTC [343] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2025-04-29 15:23:59.693 UTC [343] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2025-04-29 15:23:59.693 UTC [343] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2025-04-29 15:23:59.694 UTC [343] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2025-04-29 15:23:59.694 UTC [343] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2025-04-29 15:23:59.694 UTC [343] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr,
	 s.subpasswordrequired,
	 s.subrunasowner,
	 s.suborigin
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2025-04-29 15:23:59.695 UTC [343] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2025-04-29 15:23:59.696 UTC [343] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2025-04-29 15:23:59.696 UTC [343] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2025-04-29 15:23:59.698 UTC [343] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2025-04-29 15:23:59.699 UTC [343] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2025-04-29 15:23:59.699 UTC [343] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2025-04-29 15:23:59.705 UTC [343] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2025-04-29 15:23:59.707 UTC [343] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2025-04-29 15:23:59.707 UTC [343] LOG:  statement: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:23:59.708 UTC [343] LOG:  statement: EXECUTE dumpEnumType('16386')
2025-04-29 15:23:59.708 UTC [343] DETAIL:  prepare: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:23:59.708 UTC [343] LOG:  statement: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:23:59.708 UTC [343] LOG:  statement: EXECUTE getColumnACLs('6100')
2025-04-29 15:23:59.708 UTC [343] DETAIL:  prepare: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:23:59.709 UTC [343] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16404'::oid
2025-04-29 15:23:59.709 UTC [343] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16393'::oid
2025-04-29 15:23:59.710 UTC [343] LOG:  statement: SELECT last_value, is_called FROM public.currentbalance_id_seq
2025-04-29 15:23:59.710 UTC [343] LOG:  statement: SELECT last_value, is_called FROM public.transactions_id_seq
2025-04-29 15:23:59.710 UTC [343] LOG:  statement: COPY public.currentbalance (id, balance) TO stdout;
2025-04-29 15:23:59.710 UTC [343] LOG:  statement: COPY public.transactions (id, date, "time", type, amount, name, ref, fee, remarks, created_at, updated_at) TO stdout;
2025-04-29 15:24:17.035 UTC [360] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 15:24:17.035 UTC [362] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:24:17.035 UTC [361] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 15:24:17.035 UTC [361] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 15:24:17.087 UTC [361] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:24:20.740 UTC [364] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:24:20.741 UTC [364] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2025-04-29 15:24:20.741 UTC [364] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:24:20.741 UTC [364] LOG:  statement: SET DATESTYLE = ISO
2025-04-29 15:24:20.742 UTC [364] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2025-04-29 15:24:20.742 UTC [364] LOG:  statement: SET extra_float_digits TO 3
2025-04-29 15:24:20.742 UTC [364] LOG:  statement: SET synchronize_seqscans TO off
2025-04-29 15:24:20.743 UTC [364] LOG:  statement: SET statement_timeout = 0
2025-04-29 15:24:20.743 UTC [364] LOG:  statement: SET lock_timeout = 0
2025-04-29 15:24:20.743 UTC [364] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2025-04-29 15:24:20.743 UTC [364] LOG:  statement: SET row_security = off
2025-04-29 15:24:20.743 UTC [364] LOG:  statement: SELECT set_config(name, 'view, foreign-table', false) FROM pg_settings WHERE name = 'restrict_nonsystem_relation_kind'
2025-04-29 15:24:20.745 UTC [364] LOG:  statement: BEGIN
2025-04-29 15:24:20.745 UTC [364] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2025-04-29 15:24:20.745 UTC [364] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2025-04-29 15:24:20.746 UTC [364] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2025-04-29 15:24:20.747 UTC [364] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2025-04-29 15:24:20.748 UTC [364] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2025-04-29 15:24:20.748 UTC [364] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2025-04-29 15:24:20.751 UTC [364] LOG:  statement: LOCK TABLE public.transactions, public.currentbalance IN ACCESS SHARE MODE
2025-04-29 15:24:20.752 UTC [364] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:24:20.755 UTC [364] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2025-04-29 15:24:20.757 UTC [364] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2025-04-29 15:24:20.758 UTC [364] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:24:20.759 UTC [364] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2025-04-29 15:24:20.760 UTC [364] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2025-04-29 15:24:20.760 UTC [364] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2025-04-29 15:24:20.761 UTC [364] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2025-04-29 15:24:20.761 UTC [364] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2025-04-29 15:24:20.761 UTC [364] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2025-04-29 15:24:20.762 UTC [364] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2025-04-29 15:24:20.762 UTC [364] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2025-04-29 15:24:20.763 UTC [364] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2025-04-29 15:24:20.763 UTC [364] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2025-04-29 15:24:20.763 UTC [364] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2025-04-29 15:24:20.764 UTC [364] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2025-04-29 15:24:20.765 UTC [364] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2025-04-29 15:24:20.765 UTC [364] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2025-04-29 15:24:20.766 UTC [364] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2025-04-29 15:24:20.766 UTC [364] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2025-04-29 15:24:20.767 UTC [364] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2025-04-29 15:24:20.767 UTC [364] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2025-04-29 15:24:20.768 UTC [364] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2025-04-29 15:24:20.769 UTC [364] LOG:  statement: SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)
	ORDER BY a.adrelid, a.adnum
2025-04-29 15:24:20.769 UTC [364] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2025-04-29 15:24:20.770 UTC [364] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2025-04-29 15:24:20.773 UTC [364] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxrelid, stxstattarget FROM pg_catalog.pg_statistic_ext
2025-04-29 15:24:20.773 UTC [364] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2025-04-29 15:24:20.774 UTC [364] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2025-04-29 15:24:20.776 UTC [364] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2025-04-29 15:24:20.776 UTC [364] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2025-04-29 15:24:20.777 UTC [364] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2025-04-29 15:24:20.777 UTC [364] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2025-04-29 15:24:20.778 UTC [364] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2025-04-29 15:24:20.778 UTC [364] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr,
	 s.subpasswordrequired,
	 s.subrunasowner,
	 s.suborigin
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2025-04-29 15:24:20.778 UTC [364] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2025-04-29 15:24:20.780 UTC [364] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2025-04-29 15:24:20.780 UTC [364] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2025-04-29 15:24:20.782 UTC [364] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2025-04-29 15:24:20.783 UTC [364] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2025-04-29 15:24:20.783 UTC [364] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2025-04-29 15:24:20.789 UTC [364] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2025-04-29 15:24:20.791 UTC [364] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2025-04-29 15:24:20.791 UTC [364] LOG:  statement: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:24:20.791 UTC [364] LOG:  statement: EXECUTE dumpEnumType('16386')
2025-04-29 15:24:20.791 UTC [364] DETAIL:  prepare: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:24:20.792 UTC [364] LOG:  statement: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:24:20.792 UTC [364] LOG:  statement: EXECUTE getColumnACLs('6100')
2025-04-29 15:24:20.792 UTC [364] DETAIL:  prepare: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:24:20.793 UTC [364] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16404'::oid
2025-04-29 15:24:20.793 UTC [364] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16393'::oid
2025-04-29 15:24:20.793 UTC [364] LOG:  statement: SELECT last_value, is_called FROM public.currentbalance_id_seq
2025-04-29 15:24:20.794 UTC [364] LOG:  statement: SELECT last_value, is_called FROM public.transactions_id_seq
2025-04-29 15:24:20.794 UTC [364] LOG:  statement: COPY public.currentbalance (id, balance) TO stdout;
2025-04-29 15:24:20.794 UTC [364] LOG:  statement: COPY public.transactions (id, date, "time", type, amount, name, ref, fee, remarks, created_at, updated_at) TO stdout;
2025-04-29 15:26:07.875 UTC [458] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:26:07.876 UTC [458] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2025-04-29 15:26:07.876 UTC [458] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:26:07.876 UTC [458] LOG:  statement: SET DATESTYLE = ISO
2025-04-29 15:26:07.876 UTC [458] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2025-04-29 15:26:07.877 UTC [458] LOG:  statement: SET extra_float_digits TO 3
2025-04-29 15:26:07.877 UTC [458] LOG:  statement: SET synchronize_seqscans TO off
2025-04-29 15:26:07.877 UTC [458] LOG:  statement: SET statement_timeout = 0
2025-04-29 15:26:07.877 UTC [458] LOG:  statement: SET lock_timeout = 0
2025-04-29 15:26:07.878 UTC [458] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2025-04-29 15:26:07.878 UTC [458] LOG:  statement: SET row_security = off
2025-04-29 15:26:07.878 UTC [458] LOG:  statement: SELECT set_config(name, 'view, foreign-table', false) FROM pg_settings WHERE name = 'restrict_nonsystem_relation_kind'
2025-04-29 15:26:07.880 UTC [458] LOG:  statement: BEGIN
2025-04-29 15:26:07.880 UTC [458] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2025-04-29 15:26:07.880 UTC [458] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2025-04-29 15:26:07.881 UTC [458] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2025-04-29 15:26:07.881 UTC [458] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2025-04-29 15:26:07.882 UTC [458] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2025-04-29 15:26:07.883 UTC [458] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2025-04-29 15:26:07.886 UTC [458] LOG:  statement: LOCK TABLE public.transactions, public.currentbalance IN ACCESS SHARE MODE
2025-04-29 15:26:07.886 UTC [458] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:26:07.889 UTC [458] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2025-04-29 15:26:07.893 UTC [458] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2025-04-29 15:26:07.894 UTC [458] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:26:07.895 UTC [458] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2025-04-29 15:26:07.896 UTC [458] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2025-04-29 15:26:07.896 UTC [458] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2025-04-29 15:26:07.897 UTC [458] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2025-04-29 15:26:07.897 UTC [458] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2025-04-29 15:26:07.898 UTC [458] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2025-04-29 15:26:07.898 UTC [458] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2025-04-29 15:26:07.898 UTC [458] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2025-04-29 15:26:07.899 UTC [458] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2025-04-29 15:26:07.900 UTC [458] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2025-04-29 15:26:07.900 UTC [458] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2025-04-29 15:26:07.900 UTC [458] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2025-04-29 15:26:07.901 UTC [458] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2025-04-29 15:26:07.902 UTC [458] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2025-04-29 15:26:07.903 UTC [458] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2025-04-29 15:26:07.903 UTC [458] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2025-04-29 15:26:07.904 UTC [458] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2025-04-29 15:26:07.904 UTC [458] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2025-04-29 15:26:07.905 UTC [458] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2025-04-29 15:26:07.906 UTC [458] LOG:  statement: SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)
	ORDER BY a.adrelid, a.adnum
2025-04-29 15:26:07.907 UTC [458] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2025-04-29 15:26:07.908 UTC [458] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2025-04-29 15:26:07.911 UTC [458] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxrelid, stxstattarget FROM pg_catalog.pg_statistic_ext
2025-04-29 15:26:07.912 UTC [458] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2025-04-29 15:26:07.912 UTC [458] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2025-04-29 15:26:07.913 UTC [458] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2025-04-29 15:26:07.914 UTC [458] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2025-04-29 15:26:07.914 UTC [458] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2025-04-29 15:26:07.915 UTC [458] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2025-04-29 15:26:07.915 UTC [458] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2025-04-29 15:26:07.916 UTC [458] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr,
	 s.subpasswordrequired,
	 s.subrunasowner,
	 s.suborigin
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2025-04-29 15:26:07.916 UTC [458] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2025-04-29 15:26:07.917 UTC [458] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2025-04-29 15:26:07.918 UTC [458] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2025-04-29 15:26:07.921 UTC [458] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2025-04-29 15:26:07.921 UTC [458] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2025-04-29 15:26:07.922 UTC [458] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2025-04-29 15:26:07.931 UTC [458] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2025-04-29 15:26:07.934 UTC [458] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2025-04-29 15:26:07.935 UTC [458] LOG:  statement: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:26:07.935 UTC [458] LOG:  statement: EXECUTE dumpEnumType('16386')
2025-04-29 15:26:07.935 UTC [458] DETAIL:  prepare: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:26:07.936 UTC [458] LOG:  statement: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:26:07.936 UTC [458] LOG:  statement: EXECUTE getColumnACLs('6100')
2025-04-29 15:26:07.936 UTC [458] DETAIL:  prepare: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:26:07.937 UTC [458] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16404'::oid
2025-04-29 15:26:07.937 UTC [458] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16393'::oid
2025-04-29 15:26:07.937 UTC [458] LOG:  statement: SELECT last_value, is_called FROM public.currentbalance_id_seq
2025-04-29 15:26:07.938 UTC [458] LOG:  statement: SELECT last_value, is_called FROM public.transactions_id_seq
2025-04-29 15:26:07.938 UTC [458] LOG:  statement: COPY public.currentbalance (id, balance) TO stdout;
2025-04-29 15:26:07.938 UTC [458] LOG:  statement: COPY public.transactions (id, date, "time", type, amount, name, ref, fee, remarks, created_at, updated_at) TO stdout;
2025-04-29 15:27:09.647 UTC [510] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:27:09.648 UTC [510] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2025-04-29 15:27:09.648 UTC [510] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:27:09.648 UTC [510] LOG:  statement: SET DATESTYLE = ISO
2025-04-29 15:27:09.649 UTC [510] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2025-04-29 15:27:09.649 UTC [510] LOG:  statement: SET extra_float_digits TO 3
2025-04-29 15:27:09.649 UTC [510] LOG:  statement: SET synchronize_seqscans TO off
2025-04-29 15:27:09.649 UTC [510] LOG:  statement: SET statement_timeout = 0
2025-04-29 15:27:09.650 UTC [510] LOG:  statement: SET lock_timeout = 0
2025-04-29 15:27:09.650 UTC [510] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2025-04-29 15:27:09.650 UTC [510] LOG:  statement: SET row_security = off
2025-04-29 15:27:09.650 UTC [510] LOG:  statement: SELECT set_config(name, 'view, foreign-table', false) FROM pg_settings WHERE name = 'restrict_nonsystem_relation_kind'
2025-04-29 15:27:09.652 UTC [510] LOG:  statement: BEGIN
2025-04-29 15:27:09.652 UTC [510] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2025-04-29 15:27:09.653 UTC [510] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2025-04-29 15:27:09.654 UTC [510] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2025-04-29 15:27:09.654 UTC [510] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2025-04-29 15:27:09.655 UTC [510] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2025-04-29 15:27:09.656 UTC [510] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2025-04-29 15:27:09.660 UTC [510] LOG:  statement: LOCK TABLE public.transactions, public.currentbalance IN ACCESS SHARE MODE
2025-04-29 15:27:09.661 UTC [510] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:27:09.664 UTC [510] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2025-04-29 15:27:09.669 UTC [510] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2025-04-29 15:27:09.670 UTC [510] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:27:09.671 UTC [510] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2025-04-29 15:27:09.672 UTC [510] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2025-04-29 15:27:09.673 UTC [510] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2025-04-29 15:27:09.673 UTC [510] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2025-04-29 15:27:09.673 UTC [510] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2025-04-29 15:27:09.674 UTC [510] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2025-04-29 15:27:09.674 UTC [510] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2025-04-29 15:27:09.674 UTC [510] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2025-04-29 15:27:09.675 UTC [510] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2025-04-29 15:27:09.675 UTC [510] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2025-04-29 15:27:09.676 UTC [510] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2025-04-29 15:27:09.676 UTC [510] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2025-04-29 15:27:09.677 UTC [510] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2025-04-29 15:27:09.678 UTC [510] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2025-04-29 15:27:09.679 UTC [510] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2025-04-29 15:27:09.679 UTC [510] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2025-04-29 15:27:09.679 UTC [510] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2025-04-29 15:27:09.680 UTC [510] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2025-04-29 15:27:09.681 UTC [510] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2025-04-29 15:27:09.683 UTC [510] LOG:  statement: SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)
	ORDER BY a.adrelid, a.adnum
2025-04-29 15:27:09.684 UTC [510] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2025-04-29 15:27:09.685 UTC [510] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2025-04-29 15:27:09.688 UTC [510] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxrelid, stxstattarget FROM pg_catalog.pg_statistic_ext
2025-04-29 15:27:09.688 UTC [510] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2025-04-29 15:27:09.688 UTC [510] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2025-04-29 15:27:09.690 UTC [510] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2025-04-29 15:27:09.692 UTC [510] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2025-04-29 15:27:09.693 UTC [510] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2025-04-29 15:27:09.693 UTC [510] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2025-04-29 15:27:09.694 UTC [510] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2025-04-29 15:27:09.694 UTC [510] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr,
	 s.subpasswordrequired,
	 s.subrunasowner,
	 s.suborigin
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2025-04-29 15:27:09.694 UTC [510] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2025-04-29 15:27:09.696 UTC [510] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2025-04-29 15:27:09.696 UTC [510] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2025-04-29 15:27:09.699 UTC [510] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2025-04-29 15:27:09.700 UTC [510] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2025-04-29 15:27:09.701 UTC [510] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2025-04-29 15:27:09.708 UTC [510] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2025-04-29 15:27:09.711 UTC [510] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2025-04-29 15:27:09.711 UTC [510] LOG:  statement: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:27:09.711 UTC [510] LOG:  statement: EXECUTE dumpEnumType('16386')
2025-04-29 15:27:09.711 UTC [510] DETAIL:  prepare: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:27:09.712 UTC [510] LOG:  statement: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:27:09.712 UTC [510] LOG:  statement: EXECUTE getColumnACLs('6100')
2025-04-29 15:27:09.712 UTC [510] DETAIL:  prepare: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:27:09.713 UTC [510] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16404'::oid
2025-04-29 15:27:09.713 UTC [510] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16393'::oid
2025-04-29 15:27:09.714 UTC [510] LOG:  statement: SELECT last_value, is_called FROM public.currentbalance_id_seq
2025-04-29 15:27:09.714 UTC [510] LOG:  statement: SELECT last_value, is_called FROM public.transactions_id_seq
2025-04-29 15:27:09.714 UTC [510] LOG:  statement: COPY public.currentbalance (id, balance) TO stdout;
2025-04-29 15:27:09.714 UTC [510] LOG:  statement: COPY public.transactions (id, date, "time", type, amount, name, ref, fee, remarks, created_at, updated_at) TO stdout;
2025-04-29 15:28:22.896 UTC [570] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:28:22.896 UTC [570] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2025-04-29 15:28:22.896 UTC [570] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:28:22.896 UTC [570] LOG:  statement: SET DATESTYLE = ISO
2025-04-29 15:28:22.896 UTC [570] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2025-04-29 15:28:22.897 UTC [570] LOG:  statement: SET extra_float_digits TO 3
2025-04-29 15:28:22.897 UTC [570] LOG:  statement: SET synchronize_seqscans TO off
2025-04-29 15:28:22.897 UTC [570] LOG:  statement: SET statement_timeout = 0
2025-04-29 15:28:22.897 UTC [570] LOG:  statement: SET lock_timeout = 0
2025-04-29 15:28:22.897 UTC [570] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2025-04-29 15:28:22.897 UTC [570] LOG:  statement: SET row_security = off
2025-04-29 15:28:22.897 UTC [570] LOG:  statement: SELECT set_config(name, 'view, foreign-table', false) FROM pg_settings WHERE name = 'restrict_nonsystem_relation_kind'
2025-04-29 15:28:22.899 UTC [570] LOG:  statement: BEGIN
2025-04-29 15:28:22.899 UTC [570] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2025-04-29 15:28:22.899 UTC [570] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2025-04-29 15:28:22.900 UTC [570] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2025-04-29 15:28:22.901 UTC [570] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2025-04-29 15:28:22.902 UTC [570] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2025-04-29 15:28:22.902 UTC [570] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2025-04-29 15:28:22.907 UTC [570] LOG:  statement: LOCK TABLE public.transactions, public.currentbalance IN ACCESS SHARE MODE
2025-04-29 15:28:22.907 UTC [570] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:28:22.911 UTC [570] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2025-04-29 15:28:22.915 UTC [570] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2025-04-29 15:28:22.916 UTC [570] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:28:22.918 UTC [570] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2025-04-29 15:28:22.919 UTC [570] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2025-04-29 15:28:22.919 UTC [570] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2025-04-29 15:28:22.920 UTC [570] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2025-04-29 15:28:22.920 UTC [570] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2025-04-29 15:28:22.921 UTC [570] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2025-04-29 15:28:22.922 UTC [570] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2025-04-29 15:28:22.922 UTC [570] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2025-04-29 15:28:22.922 UTC [570] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2025-04-29 15:28:22.923 UTC [570] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2025-04-29 15:28:22.924 UTC [570] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2025-04-29 15:28:22.924 UTC [570] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2025-04-29 15:28:22.926 UTC [570] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2025-04-29 15:28:22.926 UTC [570] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2025-04-29 15:28:22.927 UTC [570] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2025-04-29 15:28:22.930 UTC [570] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2025-04-29 15:28:22.930 UTC [570] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2025-04-29 15:28:22.931 UTC [570] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2025-04-29 15:28:22.932 UTC [570] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2025-04-29 15:28:22.933 UTC [570] LOG:  statement: SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)
	ORDER BY a.adrelid, a.adnum
2025-04-29 15:28:22.934 UTC [570] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2025-04-29 15:28:22.936 UTC [570] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2025-04-29 15:28:22.939 UTC [570] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxrelid, stxstattarget FROM pg_catalog.pg_statistic_ext
2025-04-29 15:28:22.940 UTC [570] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2025-04-29 15:28:22.941 UTC [570] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2025-04-29 15:28:22.942 UTC [570] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2025-04-29 15:28:22.943 UTC [570] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2025-04-29 15:28:22.944 UTC [570] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2025-04-29 15:28:22.944 UTC [570] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2025-04-29 15:28:22.945 UTC [570] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2025-04-29 15:28:22.945 UTC [570] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr,
	 s.subpasswordrequired,
	 s.subrunasowner,
	 s.suborigin
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2025-04-29 15:28:22.947 UTC [570] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2025-04-29 15:28:22.948 UTC [570] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2025-04-29 15:28:22.949 UTC [570] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2025-04-29 15:28:22.952 UTC [570] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2025-04-29 15:28:22.953 UTC [570] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2025-04-29 15:28:22.954 UTC [570] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2025-04-29 15:28:22.961 UTC [570] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2025-04-29 15:28:22.963 UTC [570] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2025-04-29 15:28:22.964 UTC [570] LOG:  statement: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:28:22.964 UTC [570] LOG:  statement: EXECUTE dumpEnumType('16386')
2025-04-29 15:28:22.964 UTC [570] DETAIL:  prepare: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:28:22.965 UTC [570] LOG:  statement: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:28:22.965 UTC [570] LOG:  statement: EXECUTE getColumnACLs('6100')
2025-04-29 15:28:22.965 UTC [570] DETAIL:  prepare: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:28:22.967 UTC [570] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16404'::oid
2025-04-29 15:28:22.967 UTC [570] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16393'::oid
2025-04-29 15:28:22.968 UTC [570] LOG:  statement: SELECT last_value, is_called FROM public.currentbalance_id_seq
2025-04-29 15:28:22.968 UTC [570] LOG:  statement: SELECT last_value, is_called FROM public.transactions_id_seq
2025-04-29 15:28:22.969 UTC [570] LOG:  statement: COPY public.currentbalance (id, balance) TO stdout;
2025-04-29 15:28:22.969 UTC [570] LOG:  statement: COPY public.transactions (id, date, "time", type, amount, name, ref, fee, remarks, created_at, updated_at) TO stdout;
2025-04-29 15:28:29.522 UTC [580] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:28:29.524 UTC [579] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 15:28:29.524 UTC [579] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 15:28:29.527 UTC [581] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 15:28:29.562 UTC [581] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:28:34.597 UTC [582] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:28:34.597 UTC [582] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2025-04-29 15:28:34.598 UTC [582] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:28:34.598 UTC [582] LOG:  statement: SET DATESTYLE = ISO
2025-04-29 15:28:34.599 UTC [582] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2025-04-29 15:28:34.599 UTC [582] LOG:  statement: SET extra_float_digits TO 3
2025-04-29 15:28:34.599 UTC [582] LOG:  statement: SET synchronize_seqscans TO off
2025-04-29 15:28:34.600 UTC [582] LOG:  statement: SET statement_timeout = 0
2025-04-29 15:28:34.600 UTC [582] LOG:  statement: SET lock_timeout = 0
2025-04-29 15:28:34.601 UTC [582] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2025-04-29 15:28:34.601 UTC [582] LOG:  statement: SET row_security = off
2025-04-29 15:28:34.601 UTC [582] LOG:  statement: SELECT set_config(name, 'view, foreign-table', false) FROM pg_settings WHERE name = 'restrict_nonsystem_relation_kind'
2025-04-29 15:28:34.603 UTC [582] LOG:  statement: BEGIN
2025-04-29 15:28:34.603 UTC [582] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2025-04-29 15:28:34.603 UTC [582] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2025-04-29 15:28:34.604 UTC [582] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2025-04-29 15:28:34.605 UTC [582] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2025-04-29 15:28:34.606 UTC [582] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2025-04-29 15:28:34.606 UTC [582] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2025-04-29 15:28:34.609 UTC [582] LOG:  statement: LOCK TABLE public.transactions, public.currentbalance IN ACCESS SHARE MODE
2025-04-29 15:28:34.609 UTC [582] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:28:34.612 UTC [582] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2025-04-29 15:28:34.615 UTC [582] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2025-04-29 15:28:34.616 UTC [582] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:28:34.617 UTC [582] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2025-04-29 15:28:34.618 UTC [582] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2025-04-29 15:28:34.618 UTC [582] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2025-04-29 15:28:34.618 UTC [582] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2025-04-29 15:28:34.619 UTC [582] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2025-04-29 15:28:34.619 UTC [582] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2025-04-29 15:28:34.620 UTC [582] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2025-04-29 15:28:34.620 UTC [582] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2025-04-29 15:28:34.620 UTC [582] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2025-04-29 15:28:34.621 UTC [582] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2025-04-29 15:28:34.621 UTC [582] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2025-04-29 15:28:34.621 UTC [582] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2025-04-29 15:28:34.622 UTC [582] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2025-04-29 15:28:34.623 UTC [582] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2025-04-29 15:28:34.623 UTC [582] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2025-04-29 15:28:34.624 UTC [582] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2025-04-29 15:28:34.624 UTC [582] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2025-04-29 15:28:34.624 UTC [582] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2025-04-29 15:28:34.625 UTC [582] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2025-04-29 15:28:34.626 UTC [582] LOG:  statement: SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)
	ORDER BY a.adrelid, a.adnum
2025-04-29 15:28:34.627 UTC [582] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2025-04-29 15:28:34.628 UTC [582] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2025-04-29 15:28:34.632 UTC [582] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxrelid, stxstattarget FROM pg_catalog.pg_statistic_ext
2025-04-29 15:28:34.632 UTC [582] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2025-04-29 15:28:34.633 UTC [582] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2025-04-29 15:28:34.633 UTC [582] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2025-04-29 15:28:34.634 UTC [582] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2025-04-29 15:28:34.635 UTC [582] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2025-04-29 15:28:34.635 UTC [582] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2025-04-29 15:28:34.636 UTC [582] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2025-04-29 15:28:34.636 UTC [582] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr,
	 s.subpasswordrequired,
	 s.subrunasowner,
	 s.suborigin
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2025-04-29 15:28:34.637 UTC [582] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2025-04-29 15:28:34.638 UTC [582] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2025-04-29 15:28:34.638 UTC [582] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2025-04-29 15:28:34.641 UTC [582] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2025-04-29 15:28:34.641 UTC [582] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2025-04-29 15:28:34.642 UTC [582] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2025-04-29 15:28:34.649 UTC [582] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2025-04-29 15:28:34.652 UTC [582] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2025-04-29 15:28:34.652 UTC [582] LOG:  statement: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:28:34.653 UTC [582] LOG:  statement: EXECUTE dumpEnumType('16386')
2025-04-29 15:28:34.653 UTC [582] DETAIL:  prepare: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:28:34.654 UTC [582] LOG:  statement: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:28:34.654 UTC [582] LOG:  statement: EXECUTE getColumnACLs('6100')
2025-04-29 15:28:34.654 UTC [582] DETAIL:  prepare: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:28:34.655 UTC [582] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16404'::oid
2025-04-29 15:28:34.655 UTC [582] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16393'::oid
2025-04-29 15:28:34.655 UTC [582] LOG:  statement: SELECT last_value, is_called FROM public.currentbalance_id_seq
2025-04-29 15:28:34.656 UTC [582] LOG:  statement: SELECT last_value, is_called FROM public.transactions_id_seq
2025-04-29 15:28:34.656 UTC [582] LOG:  statement: COPY public.currentbalance (id, balance) TO stdout;
2025-04-29 15:28:34.656 UTC [582] LOG:  statement: COPY public.transactions (id, date, "time", type, amount, name, ref, fee, remarks, created_at, updated_at) TO stdout;
2025-04-29 15:29:05.381 UTC [610] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 15:29:05.381 UTC [611] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:29:05.381 UTC [609] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 15:29:05.381 UTC [609] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 15:29:05.387 UTC [611] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:29:08.973 UTC [620] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:29:08.974 UTC [620] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2025-04-29 15:29:08.974 UTC [620] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:29:08.974 UTC [620] LOG:  statement: SET DATESTYLE = ISO
2025-04-29 15:29:08.974 UTC [620] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2025-04-29 15:29:08.975 UTC [620] LOG:  statement: SET extra_float_digits TO 3
2025-04-29 15:29:08.975 UTC [620] LOG:  statement: SET synchronize_seqscans TO off
2025-04-29 15:29:08.975 UTC [620] LOG:  statement: SET statement_timeout = 0
2025-04-29 15:29:08.975 UTC [620] LOG:  statement: SET lock_timeout = 0
2025-04-29 15:29:08.976 UTC [620] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2025-04-29 15:29:08.976 UTC [620] LOG:  statement: SET row_security = off
2025-04-29 15:29:08.976 UTC [620] LOG:  statement: SELECT set_config(name, 'view, foreign-table', false) FROM pg_settings WHERE name = 'restrict_nonsystem_relation_kind'
2025-04-29 15:29:08.977 UTC [620] LOG:  statement: BEGIN
2025-04-29 15:29:08.977 UTC [620] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2025-04-29 15:29:08.977 UTC [620] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2025-04-29 15:29:08.978 UTC [620] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2025-04-29 15:29:08.979 UTC [620] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2025-04-29 15:29:08.979 UTC [620] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2025-04-29 15:29:08.980 UTC [620] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2025-04-29 15:29:08.983 UTC [620] LOG:  statement: LOCK TABLE public.transactions, public.currentbalance IN ACCESS SHARE MODE
2025-04-29 15:29:08.983 UTC [620] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:29:08.986 UTC [620] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2025-04-29 15:29:08.990 UTC [620] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2025-04-29 15:29:08.991 UTC [620] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:29:08.992 UTC [620] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2025-04-29 15:29:08.993 UTC [620] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2025-04-29 15:29:08.993 UTC [620] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2025-04-29 15:29:08.994 UTC [620] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2025-04-29 15:29:08.995 UTC [620] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2025-04-29 15:29:08.996 UTC [620] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2025-04-29 15:29:08.997 UTC [620] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2025-04-29 15:29:08.997 UTC [620] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2025-04-29 15:29:08.998 UTC [620] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2025-04-29 15:29:08.998 UTC [620] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2025-04-29 15:29:08.999 UTC [620] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2025-04-29 15:29:08.999 UTC [620] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2025-04-29 15:29:09.002 UTC [620] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2025-04-29 15:29:09.003 UTC [620] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2025-04-29 15:29:09.005 UTC [620] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2025-04-29 15:29:09.005 UTC [620] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2025-04-29 15:29:09.006 UTC [620] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2025-04-29 15:29:09.007 UTC [620] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2025-04-29 15:29:09.008 UTC [620] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2025-04-29 15:29:09.009 UTC [620] LOG:  statement: SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)
	ORDER BY a.adrelid, a.adnum
2025-04-29 15:29:09.010 UTC [620] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2025-04-29 15:29:09.011 UTC [620] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2025-04-29 15:29:09.013 UTC [620] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxrelid, stxstattarget FROM pg_catalog.pg_statistic_ext
2025-04-29 15:29:09.014 UTC [620] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2025-04-29 15:29:09.015 UTC [620] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2025-04-29 15:29:09.015 UTC [620] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2025-04-29 15:29:09.017 UTC [620] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2025-04-29 15:29:09.018 UTC [620] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2025-04-29 15:29:09.019 UTC [620] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2025-04-29 15:29:09.020 UTC [620] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2025-04-29 15:29:09.020 UTC [620] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr,
	 s.subpasswordrequired,
	 s.subrunasowner,
	 s.suborigin
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2025-04-29 15:29:09.021 UTC [620] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2025-04-29 15:29:09.023 UTC [620] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2025-04-29 15:29:09.023 UTC [620] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2025-04-29 15:29:09.026 UTC [620] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2025-04-29 15:29:09.026 UTC [620] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2025-04-29 15:29:09.027 UTC [620] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2025-04-29 15:29:09.034 UTC [620] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2025-04-29 15:29:09.037 UTC [620] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2025-04-29 15:29:09.037 UTC [620] LOG:  statement: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:29:09.038 UTC [620] LOG:  statement: EXECUTE dumpEnumType('16386')
2025-04-29 15:29:09.038 UTC [620] DETAIL:  prepare: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:29:09.038 UTC [620] LOG:  statement: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:29:09.039 UTC [620] LOG:  statement: EXECUTE getColumnACLs('6100')
2025-04-29 15:29:09.039 UTC [620] DETAIL:  prepare: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:29:09.039 UTC [620] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16404'::oid
2025-04-29 15:29:09.040 UTC [620] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16393'::oid
2025-04-29 15:29:09.040 UTC [620] LOG:  statement: SELECT last_value, is_called FROM public.currentbalance_id_seq
2025-04-29 15:29:09.041 UTC [620] LOG:  statement: SELECT last_value, is_called FROM public.transactions_id_seq
2025-04-29 15:29:09.041 UTC [620] LOG:  statement: COPY public.currentbalance (id, balance) TO stdout;
2025-04-29 15:29:09.041 UTC [620] LOG:  statement: COPY public.transactions (id, date, "time", type, amount, name, ref, fee, remarks, created_at, updated_at) TO stdout;
2025-04-29 15:29:23.603 UTC [630] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 15:29:23.604 UTC [632] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:29:23.604 UTC [631] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 15:29:23.604 UTC [631] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 15:29:23.611 UTC [632] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:29:27.649 UTC [641] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:29:27.650 UTC [641] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2025-04-29 15:29:27.650 UTC [641] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 15:29:27.650 UTC [641] LOG:  statement: SET DATESTYLE = ISO
2025-04-29 15:29:27.650 UTC [641] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2025-04-29 15:29:27.651 UTC [641] LOG:  statement: SET extra_float_digits TO 3
2025-04-29 15:29:27.651 UTC [641] LOG:  statement: SET synchronize_seqscans TO off
2025-04-29 15:29:27.651 UTC [641] LOG:  statement: SET statement_timeout = 0
2025-04-29 15:29:27.651 UTC [641] LOG:  statement: SET lock_timeout = 0
2025-04-29 15:29:27.651 UTC [641] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2025-04-29 15:29:27.651 UTC [641] LOG:  statement: SET row_security = off
2025-04-29 15:29:27.651 UTC [641] LOG:  statement: SELECT set_config(name, 'view, foreign-table', false) FROM pg_settings WHERE name = 'restrict_nonsystem_relation_kind'
2025-04-29 15:29:27.653 UTC [641] LOG:  statement: BEGIN
2025-04-29 15:29:27.653 UTC [641] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2025-04-29 15:29:27.653 UTC [641] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2025-04-29 15:29:27.654 UTC [641] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2025-04-29 15:29:27.654 UTC [641] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2025-04-29 15:29:27.655 UTC [641] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2025-04-29 15:29:27.655 UTC [641] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2025-04-29 15:29:27.658 UTC [641] LOG:  statement: LOCK TABLE public.transactions, public.currentbalance IN ACCESS SHARE MODE
2025-04-29 15:29:27.658 UTC [641] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:29:27.662 UTC [641] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2025-04-29 15:29:27.666 UTC [641] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2025-04-29 15:29:27.666 UTC [641] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 15:29:27.667 UTC [641] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2025-04-29 15:29:27.669 UTC [641] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2025-04-29 15:29:27.669 UTC [641] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2025-04-29 15:29:27.670 UTC [641] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2025-04-29 15:29:27.671 UTC [641] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2025-04-29 15:29:27.672 UTC [641] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2025-04-29 15:29:27.672 UTC [641] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2025-04-29 15:29:27.673 UTC [641] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2025-04-29 15:29:27.673 UTC [641] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2025-04-29 15:29:27.674 UTC [641] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2025-04-29 15:29:27.674 UTC [641] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2025-04-29 15:29:27.675 UTC [641] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2025-04-29 15:29:27.676 UTC [641] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2025-04-29 15:29:27.677 UTC [641] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2025-04-29 15:29:27.678 UTC [641] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2025-04-29 15:29:27.679 UTC [641] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2025-04-29 15:29:27.679 UTC [641] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2025-04-29 15:29:27.681 UTC [641] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2025-04-29 15:29:27.682 UTC [641] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2025-04-29 15:29:27.683 UTC [641] LOG:  statement: SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)
	ORDER BY a.adrelid, a.adnum
2025-04-29 15:29:27.685 UTC [641] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2025-04-29 15:29:27.686 UTC [641] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2025-04-29 15:29:27.688 UTC [641] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxrelid, stxstattarget FROM pg_catalog.pg_statistic_ext
2025-04-29 15:29:27.689 UTC [641] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2025-04-29 15:29:27.689 UTC [641] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2025-04-29 15:29:27.690 UTC [641] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2025-04-29 15:29:27.691 UTC [641] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2025-04-29 15:29:27.693 UTC [641] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2025-04-29 15:29:27.693 UTC [641] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2025-04-29 15:29:27.694 UTC [641] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2025-04-29 15:29:27.695 UTC [641] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr,
	 s.subpasswordrequired,
	 s.subrunasowner,
	 s.suborigin
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2025-04-29 15:29:27.695 UTC [641] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2025-04-29 15:29:27.697 UTC [641] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2025-04-29 15:29:27.698 UTC [641] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2025-04-29 15:29:27.700 UTC [641] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2025-04-29 15:29:27.701 UTC [641] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2025-04-29 15:29:27.701 UTC [641] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2025-04-29 15:29:27.708 UTC [641] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2025-04-29 15:29:27.711 UTC [641] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2025-04-29 15:29:27.711 UTC [641] LOG:  statement: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:29:27.711 UTC [641] LOG:  statement: EXECUTE dumpEnumType('16386')
2025-04-29 15:29:27.711 UTC [641] DETAIL:  prepare: PREPARE dumpEnumType(pg_catalog.oid) AS
	SELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder
2025-04-29 15:29:27.712 UTC [641] LOG:  statement: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:29:27.712 UTC [641] LOG:  statement: EXECUTE getColumnACLs('6100')
2025-04-29 15:29:27.712 UTC [641] DETAIL:  prepare: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2025-04-29 15:29:27.713 UTC [641] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16404'::oid
2025-04-29 15:29:27.713 UTC [641] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16393'::oid
2025-04-29 15:29:27.714 UTC [641] LOG:  statement: SELECT last_value, is_called FROM public.currentbalance_id_seq
2025-04-29 15:29:27.714 UTC [641] LOG:  statement: SELECT last_value, is_called FROM public.transactions_id_seq
2025-04-29 15:29:27.715 UTC [641] LOG:  statement: COPY public.currentbalance (id, balance) TO stdout;
2025-04-29 15:29:27.715 UTC [641] LOG:  statement: COPY public.transactions (id, date, "time", type, amount, name, ref, fee, remarks, created_at, updated_at) TO stdout;
2025-04-29 15:34:22.337 UTC [886] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 15:34:22.338 UTC [888] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:34:22.339 UTC [887] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 15:34:22.339 UTC [887] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 15:34:22.352 UTC [886] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 15:34:48.620 UTC [913] FATAL:  could not open file "global/pg_filenode.map": No such file or directory
2025-04-29 15:34:58.248 UTC [1] LOG:  could not open file "postmaster.pid": No such file or directory
2025-04-29 15:34:58.248 UTC [1] LOG:  performing immediate shutdown because data directory lock file is invalid
2025-04-29 15:34:58.248 UTC [1] LOG:  received immediate shutdown request
2025-04-29 15:34:58.248 UTC [1] LOG:  could not open file "postmaster.pid": No such file or directory
2025-04-29 15:34:58.254 UTC [1] LOG:  database system is shut down
