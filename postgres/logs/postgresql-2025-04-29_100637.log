2025-04-29 10:06:37.216 UTC [48] LOG:  starting PostgreSQL 16.8 (Debian 16.8-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit
2025-04-29 10:06:37.217 UTC [48] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2025-04-29 10:06:37.223 UTC [52] LOG:  database system was shut down at 2025-04-29 10:06:37 UTC
2025-04-29 10:06:37.226 UTC [48] LOG:  database system is ready to accept connections
2025-04-29 10:06:37.354 UTC [58] LOG:  statement: SELECT 1 FROM pg_database WHERE datname = 'gcash_db' ;
2025-04-29 10:06:37.380 UTC [60] LOG:  statement: CREATE DATABASE "gcash_db" ;
2025-04-29 10:06:37.413 UTC [48] LOG:  received fast shutdown request
2025-04-29 10:06:37.415 UTC [48] LOG:  aborting any active transactions
2025-04-29 10:06:37.416 UTC [48] LOG:  background worker "logical replication launcher" (PID 55) exited with exit code 1
2025-04-29 10:06:37.417 UTC [50] LOG:  shutting down
2025-04-29 10:06:37.418 UTC [50] LOG:  checkpoint starting: shutdown immediate
2025-04-29 10:06:37.474 UTC [50] LOG:  checkpoint complete: wrote 922 buffers (5.6%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.012 s, sync=0.038 s, total=0.057 s; sync files=301, longest=0.004 s, average=0.001 s; distance=4255 kB, estimate=4255 kB; lsn=0/1912100, redo lsn=0/1912100
2025-04-29 10:06:37.477 UTC [48] LOG:  database system is shut down
2025-04-29 10:06:37.536 UTC [1] LOG:  starting PostgreSQL 16.8 (Debian 16.8-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit
2025-04-29 10:06:37.537 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432
2025-04-29 10:06:37.537 UTC [1] LOG:  listening on IPv6 address "::", port 5432
2025-04-29 10:06:37.540 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2025-04-29 10:06:37.544 UTC [66] LOG:  database system was shut down at 2025-04-29 10:06:37 UTC
2025-04-29 10:06:37.548 UTC [1] LOG:  database system is ready to accept connections
2025-04-29 10:06:41.441 UTC [77] FATAL:  database "kfa" does not exist
2025-04-29 10:06:42.629 UTC [79] LOG:  statement: 
	      DO $$ 
	      BEGIN
	        IF EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type') THEN
	          DROP TYPE transaction_type CASCADE;
	        END IF;
	        CREATE TYPE transaction_type AS ENUM ('Cash In', 'Cash Out', 'Load');
	      END $$;
	    
2025-04-29 10:06:42.633 UTC [79] LOG:  statement: 
	      CREATE TABLE IF NOT EXISTS Transactions (
	        id SERIAL PRIMARY KEY,
	        date TEXT NOT NULL,
	        time TEXT NOT NULL,
	        type transaction_type NOT NULL,
	        amount TEXT NOT NULL,
	        name TEXT NOT NULL,
	        ref TEXT NOT NULL,
	        fee TEXT NOT NULL,
	        remarks TEXT NOT NULL,
	        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
	      );
	    
2025-04-29 10:06:42.641 UTC [79] LOG:  statement: 
	      DO $$ 
	      BEGIN
	        IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
	                       WHERE table_name = 'transactions' AND column_name = 'created_at') THEN
	          ALTER TABLE Transactions ADD COLUMN created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;
	        END IF;
	        IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
	                       WHERE table_name = 'transactions' AND column_name = 'updated_at') THEN
	          ALTER TABLE Transactions ADD COLUMN updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;
	        END IF;
	      END $$;
	    
2025-04-29 10:06:42.648 UTC [79] LOG:  statement: 
	      CREATE TABLE IF NOT EXISTS CurrentBalance (
	        id SERIAL PRIMARY KEY,
	        balance DECIMAL NOT NULL DEFAULT 0.00
	      );
	    
2025-04-29 10:06:42.654 UTC [79] LOG:  statement: SELECT * FROM CurrentBalance
2025-04-29 10:06:42.655 UTC [79] LOG:  statement: INSERT INTO CurrentBalance (balance) VALUES (0.00)
2025-04-29 10:06:46.512 UTC [87] FATAL:  database "kfa" does not exist
2025-04-29 10:06:51.586 UTC [95] FATAL:  database "kfa" does not exist
2025-04-29 10:06:56.659 UTC [105] FATAL:  database "kfa" does not exist
2025-04-29 10:06:59.258 UTC [97] LOG:  statement: create database kfa;
2025-04-29 10:07:14.458 UTC [132] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 10:07:14.459 UTC [134] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 10:07:14.460 UTC [133] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 10:07:14.460 UTC [133] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 10:07:14.505 UTC [133] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 10:07:24.143 UTC [133] LOG:  execute <unnamed>: UPDATE CurrentBalance SET balance = $1 WHERE id = 1
2025-04-29 10:07:24.143 UTC [133] DETAIL:  parameters: $1 = '5000'
2025-04-29 10:07:25.451 UTC [133] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 10:07:36.313 UTC [175] LOG:  execute <unnamed>: INSERT INTO Transactions (date, time, type, amount, name, ref, fee, remarks, created_at, updated_at)
	       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
	       RETURNING id
2025-04-29 10:07:36.313 UTC [175] DETAIL:  parameters: $1 = '2025-04-29', $2 = '18:07', $3 = 'Cash Out', $4 = '580', $5 = 'KEV', $6 = '12345', $7 = '20', $8 = 'CLAIMED'
2025-04-29 10:07:36.322 UTC [175] LOG:  execute <unnamed>: UPDATE CurrentBalance SET balance = balance + $1 WHERE id = 1
2025-04-29 10:07:36.322 UTC [175] DETAIL:  parameters: $1 = '580'
2025-04-29 10:07:36.996 UTC [175] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 10:07:36.996 UTC [175] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 10:07:36.999 UTC [175] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 10:07:37.007 UTC [175] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 10:07:50.185 UTC [201] LOG:  execute <unnamed>: INSERT INTO Transactions (date, time, type, amount, name, ref, fee, remarks, created_at, updated_at)
	       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
	       RETURNING id
2025-04-29 10:07:50.185 UTC [201] DETAIL:  parameters: $1 = '2025-04-29', $2 = '19:08', $3 = 'Cash In', $4 = '250', $5 = 'KFA', $6 = '12223', $7 = '10', $8 = 'SENT'
2025-04-29 10:07:50.188 UTC [201] LOG:  execute <unnamed>: UPDATE CurrentBalance SET balance = balance + $1 WHERE id = 1
2025-04-29 10:07:50.188 UTC [201] DETAIL:  parameters: $1 = '-250'
2025-04-29 10:07:50.658 UTC [201] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 10:07:50.658 UTC [201] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 10:07:50.660 UTC [201] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 10:07:50.669 UTC [201] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 10:08:05.585 UTC [227] LOG:  execute <unnamed>: INSERT INTO Transactions (date, time, type, amount, name, ref, fee, remarks, created_at, updated_at)
	       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
	       RETURNING id
2025-04-29 10:08:05.585 UTC [227] DETAIL:  parameters: $1 = '2025-04-29', $2 = '19:08', $3 = 'Cash In', $4 = '50', $5 = 'AN50', $6 = '1222141', $7 = '5', $8 = 'LOAD'
2025-04-29 10:08:05.587 UTC [227] LOG:  execute <unnamed>: UPDATE CurrentBalance SET balance = balance + $1 WHERE id = 1
2025-04-29 10:08:05.587 UTC [227] DETAIL:  parameters: $1 = '-50'
2025-04-29 10:08:03.542 UTC [227] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 10:08:03.542 UTC [227] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 10:08:03.544 UTC [227] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 10:08:03.551 UTC [227] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 10:08:10.431 UTC [227] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 10:08:10.431 UTC [227] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 10:08:10.445 UTC [227] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 10:08:12.713 UTC [227] LOG:  statement: 
	      SELECT 
	        TO_CHAR(TO_DATE(date, 'YYYY-MM-DD'), 'YYYY-MM') AS month,
	        COUNT(*) AS total_transactions,
	        SUM(CAST(amount AS DECIMAL)) AS total_amount,
	        SUM(CAST(fee AS DECIMAL)) AS total_fee
	      FROM Transactions
	      GROUP BY TO_CHAR(TO_DATE(date, 'YYYY-MM-DD'), 'YYYY-MM')
	      ORDER BY month DESC
	    
2025-04-29 10:08:12.717 UTC [227] LOG:  execute <unnamed>: 
	      SELECT SUM(CAST(fee AS DECIMAL)) AS total_fee
	      FROM Transactions
	      WHERE TO_CHAR(TO_DATE(date, 'YYYY-MM-DD'), 'YYYY-MM') = $1
	    
2025-04-29 10:08:12.717 UTC [227] DETAIL:  parameters: $1 = '2025-04'
2025-04-29 10:08:12.717 UTC [227] LOG:  execute <unnamed>: 
	      SELECT SUM(CAST(fee AS DECIMAL)) AS total_fee
	      FROM Transactions
	      WHERE TO_CHAR(TO_DATE(date, 'YYYY-MM-DD'), 'YYYY-MM') = $1
	    
2025-04-29 10:08:12.717 UTC [227] DETAIL:  parameters: $1 = '2025-03'
2025-04-29 10:08:31.218 UTC [278] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 10:08:31.218 UTC [278] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 10:08:31.229 UTC [278] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 10:08:39.561 UTC [296] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 10:08:39.562 UTC [297] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 10:08:39.562 UTC [297] DETAIL:  parameters: $1 = '2025-03-28'
2025-04-29 10:08:39.569 UTC [297] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 10:08:58.364 UTC [323] LOG:  execute <unnamed>: INSERT INTO Transactions (date, time, type, amount, name, ref, fee, remarks, created_at, updated_at)
	       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
	       RETURNING id
2025-04-29 10:08:58.364 UTC [323] DETAIL:  parameters: $1 = '2025-03-27', $2 = '18:08', $3 = 'Cash In', $4 = '200', $5 = 'KFA', $6 = '52412', $7 = '10', $8 = 'SENT'
2025-04-29 10:08:58.366 UTC [323] LOG:  execute <unnamed>: UPDATE CurrentBalance SET balance = balance + $1 WHERE id = 1
2025-04-29 10:08:58.366 UTC [323] DETAIL:  parameters: $1 = '-200'
2025-04-29 10:08:58.913 UTC [323] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 10:08:58.913 UTC [323] DETAIL:  parameters: $1 = '2025-03-28'
2025-04-29 10:08:58.915 UTC [323] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 10:08:58.920 UTC [323] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 10:09:04.454 UTC [323] LOG:  statement: 
	      SELECT 
	        TO_CHAR(TO_DATE(date, 'YYYY-MM-DD'), 'YYYY-MM') AS month,
	        COUNT(*) AS total_transactions,
	        SUM(CAST(amount AS DECIMAL)) AS total_amount,
	        SUM(CAST(fee AS DECIMAL)) AS total_fee
	      FROM Transactions
	      GROUP BY TO_CHAR(TO_DATE(date, 'YYYY-MM-DD'), 'YYYY-MM')
	      ORDER BY month DESC
	    
2025-04-29 10:09:04.465 UTC [340] LOG:  execute <unnamed>: 
	      SELECT SUM(CAST(fee AS DECIMAL)) AS total_fee
	      FROM Transactions
	      WHERE TO_CHAR(TO_DATE(date, 'YYYY-MM-DD'), 'YYYY-MM') = $1
	    
2025-04-29 10:09:04.465 UTC [340] DETAIL:  parameters: $1 = '2025-04'
2025-04-29 10:09:04.465 UTC [340] LOG:  execute <unnamed>: 
	      SELECT SUM(CAST(fee AS DECIMAL)) AS total_fee
	      FROM Transactions
	      WHERE TO_CHAR(TO_DATE(date, 'YYYY-MM-DD'), 'YYYY-MM') = $1
	    
2025-04-29 10:09:04.465 UTC [340] DETAIL:  parameters: $1 = '2025-03'
2025-04-29 10:09:09.652 UTC [340] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 10:09:09.653 UTC [323] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 10:09:09.653 UTC [323] DETAIL:  parameters: $1 = '2025-03-28'
2025-04-29 10:09:09.661 UTC [323] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 10:09:34.531 UTC [399] LOG:  execute <unnamed>: INSERT INTO Transactions (date, time, type, amount, name, ref, fee, remarks, created_at, updated_at)
	       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
	       RETURNING id
2025-04-29 10:09:34.531 UTC [399] DETAIL:  parameters: $1 = '2025-05-29', $2 = '18:09', $3 = 'Cash Out', $4 = '8000', $5 = 'KEV', $6 = '15412', $7 = '100', $8 = 'CLAIMED'
2025-04-29 10:09:34.533 UTC [399] LOG:  execute <unnamed>: UPDATE CurrentBalance SET balance = balance + $1 WHERE id = 1
2025-04-29 10:09:34.533 UTC [399] DETAIL:  parameters: $1 = '8000'
2025-04-29 10:09:35.031 UTC [399] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 10:09:35.031 UTC [399] DETAIL:  parameters: $1 = '2025-03-28'
2025-04-29 10:09:35.033 UTC [399] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 10:09:35.044 UTC [399] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 10:09:37.363 UTC [399] LOG:  statement: 
	      SELECT 
	        TO_CHAR(TO_DATE(date, 'YYYY-MM-DD'), 'YYYY-MM') AS month,
	        COUNT(*) AS total_transactions,
	        SUM(CAST(amount AS DECIMAL)) AS total_amount,
	        SUM(CAST(fee AS DECIMAL)) AS total_fee
	      FROM Transactions
	      GROUP BY TO_CHAR(TO_DATE(date, 'YYYY-MM-DD'), 'YYYY-MM')
	      ORDER BY month DESC
	    
2025-04-29 10:09:37.374 UTC [400] LOG:  execute <unnamed>: 
	      SELECT SUM(CAST(fee AS DECIMAL)) AS total_fee
	      FROM Transactions
	      WHERE TO_CHAR(TO_DATE(date, 'YYYY-MM-DD'), 'YYYY-MM') = $1
	    
2025-04-29 10:09:37.374 UTC [400] DETAIL:  parameters: $1 = '2025-04'
2025-04-29 10:09:37.374 UTC [400] LOG:  execute <unnamed>: 
	      SELECT SUM(CAST(fee AS DECIMAL)) AS total_fee
	      FROM Transactions
	      WHERE TO_CHAR(TO_DATE(date, 'YYYY-MM-DD'), 'YYYY-MM') = $1
	    
2025-04-29 10:09:37.374 UTC [400] DETAIL:  parameters: $1 = '2025-03'
2025-04-29 10:11:37.579 UTC [64] LOG:  checkpoint starting: time
2025-04-29 10:13:17.339 UTC [64] LOG:  checkpoint complete: wrote 1034 buffers (6.3%); 1 WAL file(s) added, 0 removed, 0 recycled; write=99.665 s, sync=0.059 s, total=99.760 s; sync files=360, longest=0.008 s, average=0.001 s; distance=4736 kB, estimate=4736 kB; lsn=0/1DB2238, redo lsn=0/1DB2200
2025-04-29 10:13:19.644 UTC [789] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 10:13:19.644 UTC [789] DETAIL:  parameters: $1 = '2025-03-28'
2025-04-29 10:13:19.653 UTC [789] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 10:13:22.125 UTC [789] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 10:13:22.129 UTC [789] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 10:13:22.129 UTC [789] DETAIL:  parameters: $1 = '2025-03-28'
2025-04-29 10:13:22.135 UTC [789] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 10:13:23.286 UTC [789] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 10:13:23.286 UTC [789] DETAIL:  parameters: $1 = '2025-03-28'
2025-04-29 10:13:23.294 UTC [789] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 10:13:24.586 UTC [789] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY time
2025-04-29 10:13:24.586 UTC [789] DETAIL:  parameters: $1 = '2025-03-28'
2025-04-29 10:15:14.830 UTC [996] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 10:15:14.830 UTC [996] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 10:15:14.840 UTC [996] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 10:15:16.020 UTC [996] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY time
2025-04-29 10:15:16.020 UTC [996] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 14:37:53.913 UTC [15702] LOG:  statement: SELECT c.relname, NULL::pg_catalog.text FROM pg_catalog.pg_class c WHERE (c.relname) LIKE 'tr%' AND pg_catalog.pg_table_is_visible(c.oid) AND c.relnamespace <> (SELECT oid FROM pg_catalog.pg_namespace WHERE nspname = 'pg_catalog')
	UNION ALL
	SELECT NULL::pg_catalog.text, n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname LIKE 'tr%' AND n.nspname NOT LIKE E'pg\\_%'
	LIMIT 1000
2025-04-29 14:37:54.244 UTC [15702] LOG:  statement: SELECT c.oid,
	  n.nspname,
	  c.relname
	FROM pg_catalog.pg_class c
	     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relname OPERATOR(pg_catalog.~) '^(transactions)$' COLLATE pg_catalog.default
	  AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 2, 3;
2025-04-29 14:37:54.261 UTC [15702] LOG:  statement: SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
	FROM pg_catalog.pg_class c
	 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
	LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
	WHERE c.oid = '16394';
2025-04-29 14:37:54.270 UTC [15702] LOG:  statement: SELECT a.attname,
	  pg_catalog.format_type(a.atttypid, a.atttypmod),
	  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
	   FROM pg_catalog.pg_attrdef d
	   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
	  a.attnotnull,
	  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
	   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
	  a.attidentity,
	  a.attgenerated
	FROM pg_catalog.pg_attribute a
	WHERE a.attrelid = '16394' AND a.attnum > 0 AND NOT a.attisdropped
	ORDER BY a.attnum;
2025-04-29 14:37:54.281 UTC [15702] LOG:  statement: SELECT c2.relname, i.indisprimary, i.indisunique, i.indisclustered, i.indisvalid, pg_catalog.pg_get_indexdef(i.indexrelid, 0, true),
	  pg_catalog.pg_get_constraintdef(con.oid, true), contype, condeferrable, condeferred, i.indisreplident, c2.reltablespace
	FROM pg_catalog.pg_class c, pg_catalog.pg_class c2, pg_catalog.pg_index i
	  LEFT JOIN pg_catalog.pg_constraint con ON (conrelid = i.indrelid AND conindid = i.indexrelid AND contype IN ('p','u','x'))
	WHERE c.oid = '16394' AND c.oid = i.indrelid AND i.indexrelid = c2.oid
	ORDER BY i.indisprimary DESC, c2.relname;
2025-04-29 14:37:54.288 UTC [15702] LOG:  statement: SELECT pol.polname, pol.polpermissive,
	  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
	  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
	  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
	  CASE pol.polcmd
	    WHEN 'r' THEN 'SELECT'
	    WHEN 'a' THEN 'INSERT'
	    WHEN 'w' THEN 'UPDATE'
	    WHEN 'd' THEN 'DELETE'
	    END AS cmd
	FROM pg_catalog.pg_policy pol
	WHERE pol.polrelid = '16394' ORDER BY 1;
2025-04-29 14:37:54.299 UTC [15702] LOG:  statement: SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
	pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
	  'd' = any(stxkind) AS ndist_enabled,
	  'f' = any(stxkind) AS deps_enabled,
	  'm' = any(stxkind) AS mcv_enabled,
	stxstattarget
	FROM pg_catalog.pg_statistic_ext
	WHERE stxrelid = '16394'
	ORDER BY nsp, stxname;
2025-04-29 14:37:54.302 UTC [15702] LOG:  statement: SELECT pubname
	     , NULL
	     , NULL
	FROM pg_catalog.pg_publication p
	     JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
	     JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
	WHERE pc.oid ='16394' and pg_catalog.pg_relation_is_publishable('16394')
	UNION
	SELECT pubname
	     , pg_get_expr(pr.prqual, c.oid)
	     , (CASE WHEN pr.prattrs IS NOT NULL THEN
	         (SELECT string_agg(attname, ', ')
	           FROM pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	                pg_catalog.pg_attribute
	          WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	        ELSE NULL END) FROM pg_catalog.pg_publication p
	     JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
	     JOIN pg_catalog.pg_class c ON c.oid = pr.prrelid
	WHERE pr.prrelid = '16394'
	UNION
	SELECT pubname
	     , NULL
	     , NULL
	FROM pg_catalog.pg_publication p
	WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('16394')
	ORDER BY 1;
2025-04-29 14:37:54.315 UTC [15702] LOG:  statement: SELECT c.oid::pg_catalog.regclass
	FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
	WHERE c.oid = i.inhparent AND i.inhrelid = '16394'
	  AND c.relkind != 'p' AND c.relkind != 'I'
	ORDER BY inhseqno;
2025-04-29 14:37:54.317 UTC [15702] LOG:  statement: SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
	FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
	WHERE c.oid = i.inhrelid AND i.inhparent = '16394'
	ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
2025-04-29 14:41:46.738 UTC [16094] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 14:41:46.739 UTC [16095] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 14:41:46.740 UTC [16096] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 14:41:46.740 UTC [16096] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 14:41:46.763 UTC [16094] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 14:41:55.829 UTC [16094] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 14:41:55.829 UTC [16094] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 14:41:55.850 UTC [16094] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 14:41:56.325 UTC [16094] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 14:41:56.325 UTC [16094] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 14:41:56.576 UTC [16094] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 14:42:02.608 UTC [16094] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 14:42:02.632 UTC [16122] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 14:42:02.632 UTC [16122] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 14:42:02.650 UTC [16122] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 14:42:16.017 UTC [16148] LOG:  execute <unnamed>: INSERT INTO Transactions (date, time, type, amount, name, ref, fee, remarks, created_at, updated_at)
	       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
	       RETURNING id
2025-04-29 14:42:16.017 UTC [16148] DETAIL:  parameters: $1 = '2025-04-29', $2 = '22:42', $3 = 'Cash In', $4 = '200', $5 = 'KEV', $6 = '123', $7 = '10', $8 = 'SENT'
2025-04-29 14:42:16.025 UTC [16148] LOG:  execute <unnamed>: UPDATE CurrentBalance SET balance = balance + $1 WHERE id = 1
2025-04-29 14:42:16.025 UTC [16148] DETAIL:  parameters: $1 = '-200'
2025-04-29 14:42:16.340 UTC [16148] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 14:42:16.340 UTC [16148] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 14:42:16.344 UTC [16148] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 14:42:16.349 UTC [16148] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 14:42:35.051 UTC [16174] LOG:  execute <unnamed>: INSERT INTO Transactions (date, time, type, amount, name, ref, fee, remarks, created_at, updated_at)
	       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
	       RETURNING id
2025-04-29 14:42:35.051 UTC [16174] DETAIL:  parameters: $1 = '2025-04-29', $2 = '22:42', $3 = 'Cash Out', $4 = '500', $5 = 'KEV', $6 = '12345', $7 = '10', $8 = 'CLAIMED'
2025-04-29 14:42:35.055 UTC [16174] LOG:  execute <unnamed>: UPDATE CurrentBalance SET balance = balance + $1 WHERE id = 1
2025-04-29 14:42:35.055 UTC [16174] DETAIL:  parameters: $1 = '500'
2025-04-29 14:42:35.985 UTC [16174] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 14:42:35.985 UTC [16174] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 14:42:35.988 UTC [16174] LOG:  statement: SELECT balance FROM CurrentBalance WHERE id = 1
2025-04-29 14:42:35.996 UTC [16174] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 14:42:52.782 UTC [15702] LOG:  statement: select * from transactions;
2025-04-29 14:44:00.791 UTC [16316] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 14:44:00.793 UTC [16316] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2025-04-29 14:44:00.794 UTC [16316] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 14:44:00.795 UTC [16316] LOG:  statement: SET DATESTYLE = ISO
2025-04-29 14:44:00.795 UTC [16316] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2025-04-29 14:44:00.795 UTC [16316] LOG:  statement: SET extra_float_digits TO 3
2025-04-29 14:44:00.796 UTC [16316] LOG:  statement: SET synchronize_seqscans TO off
2025-04-29 14:44:00.796 UTC [16316] LOG:  statement: SET statement_timeout = 0
2025-04-29 14:44:00.796 UTC [16316] LOG:  statement: SET lock_timeout = 0
2025-04-29 14:44:00.796 UTC [16316] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2025-04-29 14:44:00.797 UTC [16316] LOG:  statement: SET row_security = off
2025-04-29 14:44:00.797 UTC [16316] LOG:  statement: SELECT set_config(name, 'view, foreign-table', false) FROM pg_settings WHERE name = 'restrict_nonsystem_relation_kind'
2025-04-29 14:44:00.803 UTC [16316] LOG:  statement: BEGIN
2025-04-29 14:44:00.803 UTC [16316] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2025-04-29 14:44:00.804 UTC [16316] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2025-04-29 14:44:00.805 UTC [16316] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2025-04-29 14:44:00.809 UTC [16316] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2025-04-29 14:44:00.811 UTC [16316] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2025-04-29 14:44:00.813 UTC [16316] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2025-04-29 14:44:00.827 UTC [16316] LOG:  statement: LOCK TABLE public.transactions, public.currentbalance IN ACCESS SHARE MODE
2025-04-29 14:44:00.829 UTC [16316] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 14:44:00.849 UTC [16316] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2025-04-29 14:44:00.857 UTC [16316] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2025-04-29 14:44:00.859 UTC [16316] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2025-04-29 14:44:00.860 UTC [16316] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2025-04-29 14:44:00.862 UTC [16316] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2025-04-29 14:44:00.864 UTC [16316] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2025-04-29 14:44:00.865 UTC [16316] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2025-04-29 14:44:00.868 UTC [16316] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2025-04-29 14:44:00.871 UTC [16316] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2025-04-29 14:44:00.873 UTC [16316] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2025-04-29 14:44:00.876 UTC [16316] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2025-04-29 14:44:00.878 UTC [16316] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2025-04-29 14:44:00.882 UTC [16316] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2025-04-29 14:44:00.884 UTC [16316] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2025-04-29 14:44:00.886 UTC [16316] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2025-04-29 14:44:00.889 UTC [16316] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2025-04-29 14:44:00.892 UTC [16316] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2025-04-29 14:44:00.896 UTC [16316] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2025-04-29 14:44:00.896 UTC [16316] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2025-04-29 14:44:00.897 UTC [16316] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2025-04-29 14:44:00.899 UTC [16316] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2025-04-29 14:44:00.900 UTC [16316] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2025-04-29 14:44:00.901 UTC [16316] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2025-04-29 14:44:00.903 UTC [16316] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2025-04-29 14:44:00.905 UTC [16316] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxrelid, stxstattarget FROM pg_catalog.pg_statistic_ext
2025-04-29 14:44:00.906 UTC [16316] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2025-04-29 14:44:00.906 UTC [16316] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2025-04-29 14:44:00.908 UTC [16316] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2025-04-29 14:44:00.910 UTC [16316] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16394,16405}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2025-04-29 14:44:00.911 UTC [16316] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2025-04-29 14:44:00.911 UTC [16316] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2025-04-29 14:44:00.912 UTC [16316] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2025-04-29 14:44:00.912 UTC [16316] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr,
	 s.subpasswordrequired,
	 s.subrunasowner,
	 s.suborigin
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2025-04-29 14:44:00.914 UTC [16316] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2025-04-29 14:44:00.917 UTC [16316] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2025-04-29 14:44:00.918 UTC [16316] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2025-04-29 14:44:00.927 UTC [16316] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2025-04-29 14:44:00.932 UTC [16316] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2025-04-29 14:44:00.933 UTC [16316] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2025-04-29 14:44:00.944 UTC [16316] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2025-04-29 14:44:00.946 UTC [16316] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2025-04-29 14:44:00.947 UTC [16316] LOG:  statement: SELECT last_value, is_called FROM public.currentbalance_id_seq
2025-04-29 14:44:00.948 UTC [16316] LOG:  statement: SELECT last_value, is_called FROM public.transactions_id_seq
2025-04-29 14:44:00.948 UTC [16316] LOG:  statement: COPY public.currentbalance (id, balance) TO stdout;
2025-04-29 14:44:00.949 UTC [16316] LOG:  statement: COPY public.transactions (id, date, "time", type, amount, name, ref, fee, remarks, created_at, updated_at) TO stdout;
2025-04-29 14:46:50.074 UTC [64] LOG:  checkpoint starting: time
2025-04-29 14:46:51.225 UTC [64] LOG:  checkpoint complete: wrote 12 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=1.126 s, sync=0.010 s, total=1.158 s; sync files=9, longest=0.005 s, average=0.002 s; distance=2 kB, estimate=4262 kB; lsn=0/1DB2AD0, redo lsn=0/1DB2A98
2025-04-29 14:47:14.111 UTC [16625] LOG:  statement: SELECT c.relname, NULL::pg_catalog.text FROM pg_catalog.pg_class c WHERE c.relkind IN ('r', 'f', 'p') AND (c.relname) LIKE 't%' AND pg_catalog.pg_table_is_visible(c.oid) AND c.relnamespace <> (SELECT oid FROM pg_catalog.pg_namespace WHERE nspname = 'pg_catalog')
	UNION ALL
	SELECT NULL::pg_catalog.text, n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname LIKE 't%' AND n.nspname NOT LIKE E'pg\\_%'
	LIMIT 1000
2025-04-29 14:47:15.090 UTC [16625] LOG:  statement: truncate table transactions ;
2025-04-29 14:47:39.084 UTC [16677] LOG:  statement: SET statement_timeout = 0;
2025-04-29 14:47:39.084 UTC [16677] LOG:  statement: SET lock_timeout = 0;
2025-04-29 14:47:39.085 UTC [16677] LOG:  statement: SET idle_in_transaction_session_timeout = 0;
2025-04-29 14:47:39.085 UTC [16677] LOG:  statement: SET client_encoding = 'UTF8';
2025-04-29 14:47:39.085 UTC [16677] LOG:  statement: SET standard_conforming_strings = on;
2025-04-29 14:47:39.086 UTC [16677] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2025-04-29 14:47:39.086 UTC [16677] LOG:  statement: SET check_function_bodies = false;
2025-04-29 14:47:39.087 UTC [16677] LOG:  statement: SET xmloption = content;
2025-04-29 14:47:39.087 UTC [16677] LOG:  statement: SET client_min_messages = warning;
2025-04-29 14:47:39.087 UTC [16677] LOG:  statement: SET row_security = off;
2025-04-29 14:47:39.088 UTC [16677] LOG:  statement: COPY public.currentbalance (id, balance) FROM stdin;
2025-04-29 14:47:39.089 UTC [16677] ERROR:  duplicate key value violates unique constraint "currentbalance_pkey"
2025-04-29 14:47:39.089 UTC [16677] DETAIL:  Key (id)=(1) already exists.
2025-04-29 14:47:39.089 UTC [16677] CONTEXT:  COPY currentbalance, line 1
2025-04-29 14:47:39.089 UTC [16677] STATEMENT:  COPY public.currentbalance (id, balance) FROM stdin;
2025-04-29 14:47:39.090 UTC [16677] LOG:  statement: COPY public.transactions (id, date, "time", type, amount, name, ref, fee, remarks, created_at, updated_at) FROM stdin;
2025-04-29 14:47:39.100 UTC [16677] LOG:  statement: SELECT pg_catalog.setval('public.currentbalance_id_seq', 1, true);
2025-04-29 14:47:39.102 UTC [16677] LOG:  statement: SELECT pg_catalog.setval('public.transactions_id_seq', 7, true);
2025-04-29 14:48:04.467 UTC [16721] LOG:  statement: SELECT n.nspname as "Schema",
	  c.relname as "Name",
	  CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'm' THEN 'materialized view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 't' THEN 'TOAST table' WHEN 'f' THEN 'foreign table' WHEN 'p' THEN 'partitioned table' WHEN 'I' THEN 'partitioned index' END as "Type",
	  pg_catalog.pg_get_userbyid(c.relowner) as "Owner"
	FROM pg_catalog.pg_class c
	     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	     LEFT JOIN pg_catalog.pg_am am ON am.oid = c.relam
	WHERE c.relkind IN ('r','p','v','m','S','f','')
	      AND n.nspname <> 'pg_catalog'
	      AND n.nspname !~ '^pg_toast'
	      AND n.nspname <> 'information_schema'
	  AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;
2025-04-29 14:48:06.006 UTC [16721] LOG:  statement: SELECT c.relname, NULL::pg_catalog.text FROM pg_catalog.pg_class c WHERE (c.relname) LIKE 'c%' AND pg_catalog.pg_table_is_visible(c.oid) AND c.relnamespace <> (SELECT oid FROM pg_catalog.pg_namespace WHERE nspname = 'pg_catalog')
	UNION ALL
	SELECT NULL::pg_catalog.text, n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname LIKE 'c%' AND n.nspname NOT LIKE E'pg\\_%'
	LIMIT 1000
2025-04-29 14:48:09.987 UTC [16721] LOG:  statement: SELECT c.relname, NULL::pg_catalog.text FROM pg_catalog.pg_class c WHERE (c.relname) LIKE 'currentbalance\_%' AND pg_catalog.pg_table_is_visible(c.oid) AND c.relnamespace <> (SELECT oid FROM pg_catalog.pg_namespace WHERE nspname = 'pg_catalog')
	UNION ALL
	SELECT NULL::pg_catalog.text, n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname LIKE 'currentbalance\_%' AND n.nspname NOT LIKE E'pg\\_%'
	LIMIT 1000
2025-04-29 14:48:10.967 UTC [16721] LOG:  statement: SELECT c.relname, NULL::pg_catalog.text FROM pg_catalog.pg_class c WHERE (c.relname) LIKE 'currentbalance\_i%' AND pg_catalog.pg_table_is_visible(c.oid) AND c.relnamespace <> (SELECT oid FROM pg_catalog.pg_namespace WHERE nspname = 'pg_catalog')
	UNION ALL
	SELECT NULL::pg_catalog.text, n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname LIKE 'currentbalance\_i%' AND n.nspname NOT LIKE E'pg\\_%'
	LIMIT 1000
2025-04-29 14:48:11.510 UTC [16721] LOG:  statement: SELECT c.oid,
	  n.nspname,
	  c.relname
	FROM pg_catalog.pg_class c
	     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relname OPERATOR(pg_catalog.~) '^(currentbalance_id_seq)$' COLLATE pg_catalog.default
	  AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 2, 3;
2025-04-29 14:48:11.511 UTC [16721] LOG:  statement: SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
	FROM pg_catalog.pg_class c
	 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
	LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
	WHERE c.oid = '16404';
2025-04-29 14:48:11.519 UTC [16721] LOG:  statement: SELECT pg_catalog.format_type(seqtypid, NULL) AS "Type",
	       seqstart AS "Start",
	       seqmin AS "Minimum",
	       seqmax AS "Maximum",
	       seqincrement AS "Increment",
	       CASE WHEN seqcycle THEN 'yes' ELSE 'no' END AS "Cycles?",
	       seqcache AS "Cache"
	FROM pg_catalog.pg_sequence
	WHERE seqrelid = '16404';
2025-04-29 14:48:11.519 UTC [16721] LOG:  statement: SELECT pg_catalog.quote_ident(nspname) || '.' ||
	   pg_catalog.quote_ident(relname) || '.' ||
	   pg_catalog.quote_ident(attname),
	   d.deptype
	FROM pg_catalog.pg_class c
	INNER JOIN pg_catalog.pg_depend d ON c.oid=d.refobjid
	INNER JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	INNER JOIN pg_catalog.pg_attribute a ON (
	 a.attrelid=c.oid AND
	 a.attnum=d.refobjsubid)
	WHERE d.classid='pg_catalog.pg_class'::pg_catalog.regclass
	 AND d.refclassid='pg_catalog.pg_class'::pg_catalog.regclass
	 AND d.objid='16404'
	 AND d.deptype IN ('a', 'i')
2025-04-29 14:48:21.962 UTC [16721] LOG:  statement: select * from transactions;
2025-04-29 14:48:30.295 UTC [16721] LOG:  statement: SELECT c.relname, NULL::pg_catalog.text FROM pg_catalog.pg_class c WHERE c.relkind IN ('r', 'S', 'v', 'm', 'f', 'p') AND (c.relname) LIKE 'transactions\_i%' AND pg_catalog.pg_table_is_visible(c.oid) AND c.relnamespace <> (SELECT oid FROM pg_catalog.pg_namespace WHERE nspname = 'pg_catalog')
	UNION ALL
	SELECT NULL::pg_catalog.text, n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname LIKE 'transactions\_i%' AND n.nspname NOT LIKE E'pg\\_%'
	LIMIT 1000
2025-04-29 14:48:31.339 UTC [16721] LOG:  statement: select * from transactions_id_seq ;
2025-04-29 14:48:38.129 UTC [16780] LOG:  execute <unnamed>: SELECT * FROM Transactions WHERE date = $1 ORDER BY id DESC
2025-04-29 14:48:38.129 UTC [16780] DETAIL:  parameters: $1 = '2025-04-29'
2025-04-29 14:48:38.146 UTC [16780] LOG:  statement: SELECT * FROM Transactions ORDER BY id DESC LIMIT 1
2025-04-29 14:51:50.317 UTC [64] LOG:  checkpoint starting: time
2025-04-29 14:51:51.379 UTC [64] LOG:  checkpoint complete: wrote 11 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=1.015 s, sync=0.017 s, total=1.063 s; sync files=12, longest=0.012 s, average=0.002 s; distance=21 kB, estimate=3838 kB; lsn=0/1DB8030, redo lsn=0/1DB7FE0
2025-04-29 15:05:48.829 UTC [1] LOG:  received fast shutdown request
2025-04-29 15:05:48.835 UTC [1] LOG:  aborting any active transactions
2025-04-29 15:05:48.839 UTC [1] LOG:  background worker "logical replication launcher" (PID 69) exited with exit code 1
2025-04-29 15:05:48.839 UTC [64] LOG:  shutting down
2025-04-29 15:05:48.842 UTC [64] LOG:  checkpoint starting: shutdown immediate
2025-04-29 15:05:48.853 UTC [64] LOG:  checkpoint complete: wrote 0 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.002 s, sync=0.001 s, total=0.014 s; sync files=0, longest=0.000 s, average=0.000 s; distance=0 kB, estimate=3454 kB; lsn=0/1DB80E0, redo lsn=0/1DB80E0
2025-04-29 15:05:48.862 UTC [1] LOG:  database system is shut down
